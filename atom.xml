<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Huawei&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/d9115fa39cb52b129607f1045d241083</icon>
  <subtitle>流年匆忙，对错何妨</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-13T02:54:01.868Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>huawei</name>
    <email>whw19950510@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql lock level</title>
    <link href="http://yoursite.com/2018/03/12/Mysql-lock-level.html"/>
    <id>http://yoursite.com/2018/03/12/Mysql-lock-level.html</id>
    <published>2018-03-13T02:35:06.000Z</published>
    <updated>2018-03-13T02:54:01.868Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能<br><a id="more"></a><br>读锁：也叫共享锁、S锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><p>写锁：又称排他锁、X锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p><p>表锁：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。</p><p>行级锁：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。</p><p>二、MVCC实现原理<br>innodb MVCC主要是为Repeatable-Read事务隔离级别做的。在此隔离级别下，A、B客户端所示的数据相互隔离，互相更新不可见</p><p>了解innodb的行结构、Read-View的结构对于理解innodb mvcc的实现由重要意义</p><p>innodb存储的最基本row中包含一些额外的存储信息 DATA_TRX_ID，DATA_ROLL_PTR，DB_ROW_ID，DELETE BIT</p><p>6字节的DATA_TRX_ID 标记了最新更新这条行记录的transaction id，每处理一个事务，其值自动+1</p><p>7字节的DATA_ROLL_PTR 指向当前记录项的rollback segment的undo log记录，找之前版本的数据就是通过这个指针</p><p>6字节的DB_ROW_ID，当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值.，这个用于索引当中<br>DELETE BIT位用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除。真正意义的删除是在commit的时候</p><p>具体的执行过程</p><p>begin-&gt;用排他锁锁定该行-&gt;记录redo log-&gt;记录undo log-&gt;修改当前行的值，写事务编号，回滚指针指向undo log中的修改前的行</p><p>上述过程确切地说是描述了UPDATE的事务过程，其实undo log分insert和update undo log，因为insert时，原始的数据并不存在，所以回滚时把insert undo log丢弃即可，而update undo log则必须遵守上述过程</p><p>下面分别以select、delete、 insert、 update语句来说明<br>SELECT</p><p>Innodb检查每行数据，确保他们符合两个标准：</p><p>1、InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于等于事务的版本)，这确保当前事务读取的行都是事务之前已经存在的，或者是由当前事务创建或修改的行</p><p>2、行的删除操作的版本一定是未定义的或者大于当前事务的版本号，确定了当前事务开始之前，行没有被删除</p><p>符合了以上两点则返回查询结果。</p><p>INSERT</p><p>InnoDB为每个新增行记录当前系统版本号作为创建ID。</p><p>DELETE</p><p>InnoDB为每个删除行的记录当前系统版本号作为行的删除ID。</p><p>UPDATE</p><p>InnoDB复制了一行。这个新行的版本号使用了系统版本号。它也把系统版本号作为了删除行的版本。</p><p>说明<br>insert操作时 “创建时间”=DB_ROW_ID，这时，“删除时间 ”是未定义的；</p><p>update时，复制新增行的“创建时间”=DB_ROW_ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务的DB_ROW_ID；</p><p>delete操作，相应数据行的“创建时间”不变，删除时间=该事务的DB_ROW_ID；</p><p>select操作对两者都不修改，只读相应的数据</p><p>三、对于MVCC的总结<br>上述更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本，这个可能与我们所理解的MVCC有较大的出入，一般我们认为MVCC有下面几个特点：<br>每行数据都存在一个版本，每次数据更新时都更新该版本<br>修改时Copy出当前版本随意修改，各个事务之间无干扰<br>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）<br>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道，而Innodb的实现方式是：<br>事务以排他锁的形式修改原始数据<br>把修改前的数据存放于undo log，通过回滚指针与主数据关联<br>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）<br>二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ </p><p>Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。</p><p>比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</p><p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MVCC (Multiversion Concurrency Control)，即多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能&lt;br&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/03/12/%E5%95%86%E6%B1%A4%E9%9D%A2%E7%BB%8F.html"/>
    <id>http://yoursite.com/2018/03/12/商汤面经.html</id>
    <published>2018-03-13T02:23:23.281Z</published>
    <updated>2018-03-13T02:53:49.382Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Java线程池"><a href="#Java线程池" class="headerlink" title="Java线程池"></a>Java线程池</h2><p>注意区分不是数据库连接池…我真蠢<br>线程池的作用：<br>线程池作用就是<strong>限制系统中执行线程的数量。</strong><br><a id="more"></a><br>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。<br>为什么要用线程池:<br>1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。<br>2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。<br>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。<br>比较重要的几个类：<br>ExecutorService:真正的线程池接口。<br>ScheduledExecutorService:能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。<br>ThreadPoolExecutor:ExecutorService的默认实现。<br>ScheduledThreadPoolExecutor:继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。<br>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。<br>Java通过Executors提供四种线程池，分别为：<br><strong>newCachedThreadPool</strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.<br>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待.<br><strong>newScheduledThreadPool</strong>创建一个定长线程池，支持定时及周期性任务执行.<br>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行.</p><h2 id="Java-Object"><a href="#Java-Object" class="headerlink" title="Java Object"></a>Java Object</h2><p>Clone(深拷贝浅拷贝);equals/hashCode(),为什么要重写他们,HashMap的实现原理一定会问，具体怎么实现的呢？toString():    Returns a string representation of the object.</p><h2 id="Java数类型对象的安全性能"><a href="#Java数类型对象的安全性能" class="headerlink" title="Java数类型对象的安全性能"></a>Java数类型对象的安全性能</h2><p>Java虚拟机规范定义的许多规则中的一条：所有对基本类型的操作，除了某些对long类型和double类型的操作之外，都是原子级的。<br>目前的JVM（java虚拟机）都是将32位作为原子操作，并非64位。当线程把主存中的 long/double类型的值读到线程内存中时，可能是两次32位值的写操作，显而易见，如果几个线程同时操作，那么就可能会出现高低2个32位值出错的情况发生。<br><strong>要在线程间共享long与double字段是，必须在synchronized中操作，或是声明为volatile.</strong></p><h2 id="ConcurrentMap-amp-amp-HashMap有什么区别"><a href="#ConcurrentMap-amp-amp-HashMap有什么区别" class="headerlink" title="ConcurrentMap&amp;&amp;HashMap有什么区别"></a>ConcurrentMap&amp;&amp;HashMap有什么区别</h2><h2 id="数据库线程池"><a href="#数据库线程池" class="headerlink" title="数据库线程池"></a>数据库线程池</h2><p>连接池就是创建和管理一个连接的缓冲池技术，这些连接随时会被需要他们的线程调用。在我们连接数据库的时候如果不使用数据连接池，每一次访问数据库都去创建一个连接，这样会很消耗时间和项目的性能。<br>Proxool是sourceforge下面的一个开源数据连接池，最大的特色便是Proxool提供了监视的功能，便于发现连接泄漏的情况。 </p><h2 id="Mysql的事务机制"><a href="#Mysql的事务机制" class="headerlink" title="Mysql的事务机制"></a>Mysql的事务机制</h2><p>事务是怎么解决幻读脏读的,Seriazable(肯定不是，性能太差了).四种事务隔离层级.</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis的setkey的timeout机制你觉得应该怎么实现。Redis为什么能当成一个锁使用:单线程?</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>集合类描述一下，都包含什么东西。没有Map.HashSet的特性是什么(去重无序)</p><h2 id="Java的锁有哪些"><a href="#Java的锁有哪些" class="headerlink" title="Java的锁有哪些"></a>Java的锁有哪些</h2><p>1.3 synchronized和volatile比较<br>简单的说就是synchronized的代码块是确保可见性和原子性的, <strong>volatile只能确保可见性.</strong>当且仅当下面条件全部满足时, 才能使用volatile<br>-对变量的写入操作不依赖于变量的当前值, (++i/i++这种肯定不行), 或者能确保只有单个线程在更新<br>-该变量不会与其他状态变量一起纳入不变性条件中<br>-<strong>访问变量时不需要加锁</strong><br>juc中的锁分两种, 1. 可重入锁; 2. 读写锁. 两者都用到了一个通用组件 AbstractQueuedSynchronizer.<br>利用了一个int来表示状态, 内部基于FIFO队列及UnSafe的CAS原语作为操纵状态的数据结构, AQS以单个 int 类型的原子变量来表示其状态，定义了4个抽象方法(tryAcquire(int)、tryRelease(int)、tryAcquireShared(int)、tryReleaseShared(int)，前两个方法用于独占/排他模式，后两个用于共享模式)留给子类实现，用于自定义同步器的行为以实现特定的功能。</p><h2 id="Java创建一个新的对象的方式"><a href="#Java创建一个新的对象的方式" class="headerlink" title="Java创建一个新的对象的方式"></a>Java创建一个新的对象的方式</h2><p>new/class.forName/getClass().newInstance; 调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法. 调用对象的clone()方法。运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法.<br>查看磁盘分区的命令:df -hl.打印Tomcat日志目录的尾部:tail -n</p><h2 id="Mysql存储过程总结"><a href="#Mysql存储过程总结" class="headerlink" title="Mysql存储过程总结"></a>Mysql存储过程总结</h2><p>Mysql一般反而不使用存储过程迁移那些事务管理。<br>一.创建存储过程<br>1.基本语法：<br>create procedure sp_name()<br>begin<br>………<br>end<br>2.参数传递<br>3.调用<br>call sp_name()<br>4.删除存储过程<br>drop procedure sp_name<br>(1)不能在一个存储过程中删除另一个存储过程，只能调用另一个存储过程</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java线程池&quot;&gt;&lt;a href=&quot;#Java线程池&quot; class=&quot;headerlink&quot; title=&quot;Java线程池&quot;&gt;&lt;/a&gt;Java线程池&lt;/h2&gt;&lt;p&gt;注意区分不是数据库连接池…我真蠢&lt;br&gt;线程池的作用：&lt;br&gt;线程池作用就是&lt;strong&gt;限制系统中执行线程的数量。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/03/12/%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F.html"/>
    <id>http://yoursite.com/2018/03/12/阿里面经.html</id>
    <published>2018-03-13T02:23:23.254Z</published>
    <updated>2018-03-13T02:53:58.917Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h2><p>time_wait状态必须等待多长时间：<br>2MSL<br>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。<br><a id="more"></a><br>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>B+树是一种树数据结构，是一个n叉排序树，每个节点通常有多个孩子，一棵B+树包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。<br>B+树通常用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS和BFS等文件系统都在使用B+树作为元数据索引。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入。<br>红黑树旋转：<br>降低左子树的高度，增加右子树的高度<br>将x变为当前位置的右子节点</p><h2 id="mysql隔离级别"><a href="#mysql隔离级别" class="headerlink" title="mysql隔离级别"></a>mysql隔离级别</h2><p>事务隔离级别                脏读    不可重复读    幻读<br>读未提交（read-uncommitted）        是    是    是<br>不可重复读（read-committed）        否    是    是<br>可重复读（repeatable-read）            否    否    是<br>串行化（serializable）                否    否    否</p><p>##<br>快排最坏复杂度O(nlogn) 在最坏的情况下，待排序的序列为正序或者逆序，时间复杂度O(n^2)</p><h2 id="Mysql怎样避免幻读"><a href="#Mysql怎样避免幻读" class="headerlink" title="Mysql怎样避免幻读"></a>Mysql怎样避免幻读</h2><p>read view(或者说 MVCC)实现了一致性不锁定读(Consistent Nonlocking Reads)，从而避免了幻读<br>Innodb行锁分为:<br>类型    说明<br>Record Lock:    在索引上对单行记录加锁.<br>Gap Lock:        锁定一个范围的记录,但不包括记录本身.锁加在未使用的空闲空间上,可能是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引之后的空间.<br>Next-Key Lock:    行锁与间隙锁组合起来用就叫做Next-Key Lock。锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><ol><li>方法区</li><li>堆区</li><li>本地方法栈</li><li>虚拟机栈</li><li>程序计数器<br>其中，方法区和堆是所有线程共享的。</li></ol><p>1.自我介绍<br>2.object类里边的方法，hashcode和equals的区别，引申到map，扩容的实现，时间复杂度<br>equals:在Object类中的默认实现是“将该对象的内部地址转换成一个整数返回”。<br>1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。<br>2、如果两个对象不equals，他们的hashcode有可能相等。<br>3、如果两个对象hashcode相等，他们不一定equals。<br>4、如果两个对象hashcode不相等，他们一定不equals。 </p><p>3.wait notify ，synchronize方法，<br>4.不能够创建更多的线程数怎么排查<br>5.class的加载流程，一段java代码在栈帧中的执行过程<br>6.写一条sql，执行流程，b树怎么遍历，多少次io，二级索引查数据的流程，看了哪些书<br>7.volatile关键字的作用，被质疑这个关键字真的有用吗<br>8.打开文件流写入磁盘的过程，机械磁盘的查找过程<br>9.kafka 0拷贝机制，socket连接过程，nio和bio的区别<br>10.设计模式<br>11.nginx 和 tomcat的原理,优化….<br>12.linux命令<br>13.tcp连接数，挥手过程及状态转移<br>14.怎么学习新技术，对业务和技术的理解<br>15.股票买卖问题<br>在确定最大连接数之前，先来看看系统如何标识一个tcp连接。系统用一个4四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}。<br>client最大连接数:65535<br>server最大连接数:最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。</p><p>知道的redis全说出来 redis基于内存的，redis 的 rdb 和 aof， redis有虚拟内存，redis用的跳表。解释了一下aof和rdb 2. 虚拟内存为什么会损耗性能 我回答的是磁盘i/o、错了估计是内存映射 3. redis的瓶颈是什么 我回答单点故障 4. 说一下线程池 巴拉巴拉. 5. 说一下jvm. 6. 好了我们做一下题目 1. max point line 2. 求1000000w以内的素数<br>Redis瓶颈是单线程，所以一定要避免那种耗时的操作.</p><p>有上面分析可知：RDB方式持久化的颗粒比较大，当服务器宕机时，到上次save或bgsave后的所有数据都会丢失。而AOF的持久化颗粒比较细，当服务器宕机后，只有宕机之前没来得AOF的操作数据会丢失。<br>1.RDB持久化是redis默认的，用来生成某一个时间点的数据快照；RDB是一个经过压缩的二进制文件，采用RDB持久化时服务器只会保存一个RDB文件（维护比较简单）；<br>2.AOF实现：<br>1）AOF持久化是通过保存redis服务器所执行的写命令来记录数据库状态的；被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的（Redis的请求协议是纯文本的）。服务器在启动时，通过载入AOF文件、并执行其中的命令来还原服务器状态。<br>1.Tomcat查看tomcat日志输出<br>tail -f catalina.out命令实时查看tomcat的输出。查看系统磁盘的空间df<br>2.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三次握手四次挥手&quot;&gt;&lt;a href=&quot;#三次握手四次挥手&quot; class=&quot;headerlink&quot; title=&quot;三次握手四次挥手&quot;&gt;&lt;/a&gt;三次握手四次挥手&lt;/h2&gt;&lt;p&gt;time_wait状态必须等待多长时间：&lt;br&gt;2MSL&lt;br&gt;MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Minheap greedy solution</title>
    <link href="http://yoursite.com/2018/03/05/Minheap-greedy-solution.html"/>
    <id>http://yoursite.com/2018/03/05/Minheap-greedy-solution.html</id>
    <published>2018-03-06T01:43:11.000Z</published>
    <updated>2018-03-06T01:45:30.703Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Minheap-greedy-to-use-the-largest"><a href="#Minheap-greedy-to-use-the-largest" class="headerlink" title="Minheap greedy to use the largest"></a>Minheap greedy to use the largest</h2><p>Scheduler &amp; Reorganize String:<br>For Reorganize String, count all char in the String, in order to split them into different areas as much as possible, you just use the largest 2 in the Minheap as much as possible to make sure the Character is different.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Minheap-greedy-to-use-the-largest&quot;&gt;&lt;a href=&quot;#Minheap-greedy-to-use-the-largest&quot; cl
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Dijkstra practice</title>
    <link href="http://yoursite.com/2018/03/04/Dijkstra-practice.html"/>
    <id>http://yoursite.com/2018/03/04/Dijkstra-practice.html</id>
    <published>2018-03-04T23:45:44.000Z</published>
    <updated>2018-03-05T01:57:41.787Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Basic-summary"><a href="#Basic-summary" class="headerlink" title="Basic summary"></a>Basic summary</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> 1  function Dijkstra(G, w, s)</span><br><span class="line"> 2     for each vertex v in V[G]        // 初始化</span><br><span class="line"> 3           d[v] := infinity           // 將各點的已知最短距離先設成無窮大</span><br><span class="line"> 4           previous[v] := undefined   // 各点的已知最短路径上的前趋都未知</span><br><span class="line"> 5     d[s] := 0                        // 因为出发点到出发点间不需移动任何距离，所以可以直接将s到s的最小距离设为0</span><br><span class="line"> 6     S := empty set</span><br><span class="line"> 7     Q := set of all vertices</span><br><span class="line"> 8     while Q is not an empty set      // Dijkstra演算法主体</span><br><span class="line"> 9           u := Extract_Min(Q)</span><br><span class="line">10           S.append(u)</span><br><span class="line">11           for each edge outgoing from u as (u,v)</span><br><span class="line">12                  if d[v] &gt; d[u] + w(u,v)             // 拓展边（u,v）。w(u,v)为从u到v的路径长度。</span><br><span class="line">13                        d[v] := d[u] + w(u,v)         // 更新路径长度到更小的那个和值。</span><br><span class="line">14                        previous[v] := u              // 记录前置节点</span><br></pre></td></tr></table></figure><p>Extract_Min(Q)是提取节点使得这个节点到源节点的距离最小，每次都这么提取。需要计算所有节点的距离因此将Q设成所有节点，如果只需要计算特殊情形Q起始只有一个节点。用PriorityQueue实现res-&gt;正则很方便.</p><h2 id="变形Dj"><a href="#变形Dj" class="headerlink" title="变形Dj"></a>变形Dj</h2><p>BFS,每次不是提取Min_Q节点,仅仅BFS，因为题目要求逐跳之内到达目标节点，层序遍历走到就走到，走不到就停止。每次判断条件仍然是距离向量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Basic-summary&quot;&gt;&lt;a href=&quot;#Basic-summary&quot; class=&quot;headerlink&quot; title=&quot;Basic summary&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="dfs" scheme="http://yoursite.com/tags/dfs/"/>
    
  </entry>
  
  <entry>
    <title>DFS used up analyze</title>
    <link href="http://yoursite.com/2018/03/03/DFS-used-up-analyze.html"/>
    <id>http://yoursite.com/2018/03/03/DFS-used-up-analyze.html</id>
    <published>2018-03-04T03:22:40.000Z</published>
    <updated>2018-03-04T03:25:01.913Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>The nice thing about DFS is it tries a path, and if that’s wrong (i.e. path does not lead to solution), DFS goes one step back and tries another path. It continues to do so until we’ve found the correct path (which leads to the solution). You need to always bear this nice feature in mind when utilizing DFS to solve problems.<br><a id="more"></a><br>In this problem, the path we are going to find is an itinerary which:<br>1.<strong>uses all tickets to travel among airports</strong>2.preferably in ascending lexical order of airport code Keep in mind that requirement<br>1 must be satisfied before we consider<br>2.If we always choose the airport with the smallest lexical order, this would lead to a perfectly lexical-ordered itinerary, but pay attention that when doing so, there <strong>can be a “dead end” somewhere</strong> in the tickets such that we are not able visit all airports (or we can’t use all our tickets), which is bad because it fails to satisfy requirement 1 of this problem. Thus we need to take a step back and try other possible airports, which might not give us a perfectly ordered solution, but will use all tickets and cover all airports.</p><p>Thus it’s natural to think about the “backtracking” feature of DFS. We start by building a graph and then <strong>sorting vertices in the adjacency list</strong> so that when we traverse the graph later, we can guarantee the lexical order of the itinerary can be as good as possible. When we have generated an itinerary, we check if we have used all our airline tickets. If not, we revert the change and try another ticket. We keep trying <strong>until we have used all our tickets</strong>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    private HashMap&lt;String, List&lt;String&gt;&gt; adjList = new HashMap&lt;&gt;();</span><br><span class="line">    private LinkedList&lt;String&gt; route = new LinkedList&lt;&gt;();</span><br><span class="line">    private int numTickets = 0;</span><br><span class="line">    private int numTicketsUsed = 0;</span><br><span class="line">    </span><br><span class="line">    public List&lt;String&gt; findItinerary(String[][] tickets) &#123;</span><br><span class="line">        if (tickets == null || tickets.length == 0) return route;</span><br><span class="line">        // build graph</span><br><span class="line">        numTickets = tickets.length;</span><br><span class="line">        for (int i = 0; i &lt; tickets.length; ++i) &#123;</span><br><span class="line">            if (!adjList.containsKey(tickets[i][0])) &#123;</span><br><span class="line">                // create a new list</span><br><span class="line">                List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                list.add(tickets[i][1]);</span><br><span class="line">                adjList.put(tickets[i][0], list);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // add to existing list</span><br><span class="line">                adjList.get(tickets[i][0]).add(tickets[i][1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // sort vertices in the adjacency list so they appear in lexical order</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : adjList.entrySet()) &#123;</span><br><span class="line">            Collections.sort(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // start DFS</span><br><span class="line">        route.add(&quot;JFK&quot;);</span><br><span class="line">        dfsRoute(&quot;JFK&quot;);</span><br><span class="line">        return route;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void dfsRoute(String v) &#123;</span><br><span class="line">        // base case: vertex v is not in adjacency list</span><br><span class="line">        // v is not a starting point in any itinerary, or we would have stored it</span><br><span class="line">        // thus we have reached end point in our DFS</span><br><span class="line">        if (!adjList.containsKey(v)) return;</span><br><span class="line">        List&lt;String&gt; list = adjList.get(v);</span><br><span class="line">        for (int i = 0; i &lt; list.size(); ++i) &#123;</span><br><span class="line">            String neighbor = list.get(i);</span><br><span class="line">            // remove ticket(route) from graph</span><br><span class="line">            list.remove(i);</span><br><span class="line">            route.add(neighbor);</span><br><span class="line">            numTicketsUsed++;</span><br><span class="line">            dfsRoute(neighbor);</span><br><span class="line">            // we only return when we have used all tickets</span><br><span class="line">            if (numTickets == numTicketsUsed) return;</span><br><span class="line">            // otherwise we need to revert the changes and try other tickets</span><br><span class="line">            list.add(i, neighbor);</span><br><span class="line">            // This line took me a long time to debug</span><br><span class="line">            // we must remove the last airport, since in an itinerary, the same airport can appear many times!!</span><br><span class="line">            route.removeLast();</span><br><span class="line">            numTicketsUsed--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The nice thing about DFS is it tries a path, and if that’s wrong (i.e. path does not lead to solution), DFS goes one step back and tries another path. It continues to do so until we’ve found the correct path (which leads to the solution). You need to always bear this nice feature in mind when utilizing DFS to solve problems.&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>tensorflow-introduction</title>
    <link href="http://yoursite.com/2018/03/01/tensorflow-introduction.html"/>
    <id>http://yoursite.com/2018/03/01/tensorflow-introduction.html</id>
    <published>2018-03-01T23:59:00.000Z</published>
    <updated>2018-03-01T23:59:00.190Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java basic concept</title>
    <link href="http://yoursite.com/2018/02/28/Java-basic-concept.html"/>
    <id>http://yoursite.com/2018/02/28/Java-basic-concept.html</id>
    <published>2018-03-01T03:46:49.000Z</published>
    <updated>2018-03-02T15:44:14.199Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Java-concept"><a href="#Java-concept" class="headerlink" title="Java concept"></a>Java concept</h2><a id="more"></a><p>包装类将基本数据类型封装成数据对象(Integer).<br>如果Vector定义为保存Object则可以存放任意类型。<br>接口中常量声明必须初始化.<br>下列哪种情况可以终止当前线程的运行？抛出一个异常时.sleep()仅仅挂起<br>ServerSocket(int port) 是服务端绑定port端口，调accept()监听等待客户端连接，它返回一个连接队列中的一个socket。<br>Socket(InetAddress address , int port)是创建客户端连接主机的socket流，其中InetAddress是用来记录主机的类，port指定端口。<br><strong>Hashtable不允许null键或值</strong><br>不论程序是否发生错误及捕捉到异常情况，都会执行finally部分，当try区段的程序发生异常时，才会执行catch区段的程序。<br>在 hibernate 开发中，关于 POJO 类对象的状态说法正确的是（）。<br>自由状态（Transient）：实体在内存中自由存在，与数据库中的记录无关<br>持久状态（Persistent）：实体处于由Hibernate框架所管理的状态，对应了数据库中的一条记录，同时与某个session实例发生了关联<br>游离状态（Detached）：在session 关闭之后,可以使对象从持久状态转换到游离状态。<br><strong>抽象类可以有构造方法，接口中不能有构造方法</strong><br>抽象类中可以有普通成员变量，接口中没有普通成员变量,接口中可以有变量，但是无论你怎么写，最后都是<strong>public static final</strong>的。<br>一个类可以实现多个接口，但只能继承一个抽象类。<br>JDK中提供的java、javac、jar等开发工具也是用Java编写的<br>要使对象具有序列化能力实现java.io.Serializable,在接口内部没有定义任何属性与方法。只是用于<strong>标志此接口的实现类可以被序列化与反序列化。</strong><br>Java使用Unicode编码<br>如果在一个线程构造了一个不可变对象之后（对象仅包含final字段），就可以保证了这个对象被其他线程正确的查看。错误，指向有可能变<br>JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证<br><strong>“synchronized” — 保证在块开始时都同步主内存的值到工作内存，而块结束时将变量同步回主内存</strong>修饰整块<br>“volatile” — 保证修饰后在对变量读写前都会与主内存更新。<br>readwritelock适用于读多写少的并发场景<br>CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。<br>ReadWriteLock 当写操作时，其他线程无法读取或写入数据，而当读操作时，其它线程无法写入数据，但却可以读取数据 。适用于 读取远远大于写入的操作。<br>ConcurrentHashMap是一个线程安全的Hash Table，它的主要功能是提供了一组和HashTable功能相同但是线程安全的方法。<strong>ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，不用对整个ConcurrentHashMap加锁</strong>。<br>volatile只能保证变量的安全，不能保证线程的安全<br>jre判断程序是否执行结束的标准是<strong>所有的前台线程执行完毕</strong><br>java用（监视器）机制实现了进程之间的同步执行；jvm中没有进程的概念 ，但是jvm中的线程映射为操作系统中的进程，对应关系为1：1。在jvm中是使用监视器锁来实现不同线程的异步执行，在语法的表现就是synchronized。<br>ServletContext的参数值context.getInitParameter()</p><p>Stub(<strong>适配器模式</strong>，动态链接原理)<br>存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类实现接口，就免去了这种麻烦。<br>RMI 采用stubs 和 skeletons 来进行远程对象(remote object)的通讯。stub 充当远程对象的客户端代理，有着和远程对象相同的远程接口，远程对象的调用实际是通过调用该对象的客户端代理对象stub来完成的。<br>每个远程对象都包含一个代理对象stub，当运行在本地Java虚拟机上的程序调用运行在远程Java虚拟机上的对象方法时，它首先在本地创建该对象的代理对象stub, 然后调用代理对象上匹配的方法。每一个远程对象同时也包含一个skeleton对象，skeleton运行在远程对象所在的虚拟机上，接受来自stub对象的调用。这种方式符合等到程序要运行时将目标文件动态进行链接的思想<br>super关键字是在子类对象内部指代其父类对象的引用,可以找到父类的属性。<br>JDBC使用了<strong>桥接模式</strong>.JDBC提供两套接口，一个面向数据库厂商，一个面向JDBC使用者。<br>桥接模式：<br>定义 ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。<br>意图 ：将抽象与实现解耦。<br>桥接模式所涉及的角色 </p><ol><li>Abstraction：定义抽象接口，拥有一个Implementor类型的对象引用 </li><li>RefinedAbstraction：扩展Abstraction中的接口定义 </li><li>Implementor：是具体实现的接口，Implementor和RefinedAbstraction接口并不一定完全一致，实际上这两个接口可以完全不一样Implementor提供具体操作方法，而Abstraction提供更高层次的调用 </li><li>ConcreteImplementor：实现Implementor接口，给出具体实现<br>Jdk中的桥接模式：JDBC<br>JDBC连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不动，原因就是<strong>JDBC提供了统一接口</strong>，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了<br>JDK1.6提供的6中作用于不同年代的垃圾收集器.<br>CMS,SerilizeOld,Parallel Old,ParNew,Serial,ParallelScanvenge<br>Obejct的方法:notify();notifyAll();wait()<br>5.处理异常常用的两种方式： </li></ol><ul><li>try…catch(捕获处理机制)；  </li><li>throws(冒泡处理机制).<br>注意细节：使用try…catch块捕获时可以没有catch块,但当没用catch块的时候必须得有finally块<br>6.DBMS对数据库的保护通过4个方面来实现：<br>数据库的恢复<br>数据库的并发控制<br>数据库的完整性控制<br>数据库安全性控制<br>DBMS中实现事务持久性的子系统是恢复管理子系统。<br>7.final定义的变量可以在赋值的时候完成初始化<br>8.socket.getLocalAddress()获取本机IP<br>9.<strong>反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象，都能够调用它的任意一个方法和属性</strong>,破坏了封装机制.<br>10.HttpServlet容器响应Web客户请求流程如下：<br>1）Web客户向Servlet容器发出Http请求；<br>2）Servlet容器解析Web客户的Http请求；<br>3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；<br>4）Servlet容器创建一个HttpResponse对象；<br>5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；<br>6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；<br>7）HttpServlet调用HttpResponse的有关方法，生成响应数据；<br>8）Servlet容器把HttpServlet的响应结果传给Web客户。<br>10.结束进程:Thread.interrupt()/启动进程:Thread.start()已经启动.一个线程等待另外一个线程的方法是wait()方法<br>11.所有对象都在堆栈上分配/方法区加载类信息，线程共享；虚拟机展线程隔离.<br>12.虚拟机中没有泛型，只有普通类和普通方法。<strong>所有泛型类的类型参数在编译时都会被擦除，创建泛型对象时请指明类型，让编译器尽早的做参数检查。</strong><br>13.解决哈希冲突常用的两种方法是：开放定址法和链地址法<br>开放定址法：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放地址则表明表中无待查的关键字，即查找失败。<br>链地址法：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。<br>14.Servlet生命周期:JSP会先解释成Servlet源文件，然后编译成Servlet类文件,每当用户端运行JSP时，jsp service()方法都会运行一次.<br>15.执行forward时，浏览器不知道服务器发送的内容是从何处来，浏览器地址栏中还是原来的地址/执行redirect时，服务器端告诉浏览器重新去请求地址/forward是内部重定向，redirect是外部重定向<br>16.子类调用父类的方法:<strong>子类也可以new一个父类对象，然后调用父类方法，</strong>并不一定要使用super方法。<br>17.1）抽象类可以包括抽象方法和非抽象方法<br>2）如果类里面有抽象方法的话，那么类一定要声明为抽象的！<br>18.Class clazz = Class.forName(“work.litao.Child”);<br>//得到父类<br>Class superClass = clazz.getSuperclass();<br>//得到父类非继承的所有方法<br>Method[] methods = superClass.getDeclaredMethods();<br>19.J2EE中常用的名词解释<br>1.web容器：给处于其中的应用程序组件（JSP，SERVLET）提供一个环境，使JSP,SERVLET直接和容器中的环境变量接接口互，不必关注其它系统问题。主要有WEB服务器来实现。例如：TOMCAT,WEBLOGIC,WEBSPHERE等。该容器提供的接口严格遵守J2EE规范中的WEB APPLICATION 标准。我们把遵守以上标准的WEB服务器就叫做J2EE中的WEB容器。<br>2.Web container：实现J2EE体系结构中Web组件协议的容器。这个协议规定了一个Web组件运行时的环境，包括安全，一致性，生命周期管理，事务，配置和其它的服务。一个提供和JSP和J2EE平台APIs界面相同服务的容器。一个Web container 由Web服务器或者J2EE服务器提供。<br>3.EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。一个实现了J2EE体系结构中EJB组件规范的容器。 这个规范指定了一个Enterprise bean的运行时环境，包括安全，一致性，生命周期，事务， 配置，和其他的服务。<br>4.JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。<br>5.JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。<br>6.JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。<br>7.JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。<br>8.RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。RMI-IIOP出现以前，只有RMI和CORBA两种选择来进行分布式程序设计。RMI-IIOP综合了RMI和CORBA的优点，克服了他们的缺点，使得程序员能更方便的编写分布式程序设计，实现分布式计算。首先，RMI-IIOP综合了RMI的简单性和CORBA的多语言性（兼容性），其次RMI-IIOP克服了RMI只能用于Java的缺点和CORBA的复杂性（可以不用掌握IDL）。<br>20.JDBC提供了<strong>Statement、PreparedStatement 和 CallableStatement</strong>三种方式来执行查询语句，其中Statement用于通用查询， PreparedStatement用于执行参数化查询，而<strong>CallableStatement则是用于存储过程</strong>;<br>1.Statement、PreparedStatement和CallableStatement都是接口(interface)。<br>2.Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatement继承自PreparedStatement。<br>3.Statement接口提供了执行语句和获取结果的基本方法;PreparedStatement接口添加了处理 IN 参数的方法;CallableStatement接口添加了处理 OUT 参数的方法。<br>4.a.Statement: 普通的不带参的查询SQL；支持批量更新,批量删除;<br>b.PreparedStatement: 可变参数的SQL,编译一次,执行多次,效率高; 安全性好，有效防止Sql注入等问题; 支持批量更新,批量删除;<br>c.CallableStatement:继承自PreparedStatement,支持带参数的SQL操作; 支持调用存储过程,提供了对输出和输入/输出参数(INOUT)的支持;<br>Statement每次执行sql语句，数据库都要执行sql语句的编译,  最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement。<br>PreparedStatement是预编译的，使用PreparedStatement有几个好处<br>1.在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。<br>2.安全性好，有效防止Sql注入等问题。<br>3.对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch；<br>4.代码的可读性和可维护性。<br>21.ResultSet去索引列名主要用的是索引，从1开始也可以使用列名。<br>22.优化Hibernate所鼓励的7大措施：<br>1.尽量使用many-to-one，避免使用单项one-to-many<br>2.灵活使用单向one-to-many<br>3.不用一对一，使用多对一代替一对一<br>4.配置对象缓存，不使用集合缓存<br>5.一对多使用Bag 多对一使用Set<br>6.继承使用显示多态 HQL:from object polymorphism=”exlicit” 避免查处所有对象<br>7.消除大表，使用二级缓存<br>23.throw用于抛出异常对象，throws声明方法要抛出的异常。<br>24.Java非静态方法属于对象的成员??????<br>25.栈中主要存放一些基本类型的变量(int, short, long, byte, float, double, boolean, char)和对象句柄。<br>堆式存储：堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。<br>26.泛型仅仅是java的语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的.<br>27.Java默认提供的三个ClassLoader是BootStrap ClassLoader，Extension ClassLoader，App ClassLoader，动态加载Class文件进入内存.Bootstrap ClassLoader:负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等.<br>Extension ClassLoader:负责加载java扩展类，主要%JRE_HOME/lib/ext 目录下的jar和class.<br>App ClassLoader:负责加载当前java应用的classpath中的所有类。<br>classloader 加载类用的是全盘负责委托机制。 所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入.<br>所以，当我们自定义的classlo ader加载成功了 com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成.</li></ul><ol><li>双亲委派模型<br>我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为 类加载器的双亲委派模型 ，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用 组合关系 来复用父加载器的。</li><li>双亲委托模型的工作原理<br>是当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载这个加载请求的时候，子加载器才会尝试自己去加载。</li><li>使用双亲委派模型好处？（原因）<br>第一：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载。<br>第二：考虑到安全因素，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器。<br>28.Hibernate2延迟加载实现：a)实体对象 b)集合（Collection）<br>get支持延迟加载，load不支持延迟加，get()采用立即加载方式,而load()采用 延迟加载 ; get()方法执行的时候,会立即向数据库发出查询语句, 而load()方法返回的是一个代理(此代理中只有一个id属性),只有等真正使用该对象属性的时候,才会发出 sql语句 2.如果数据库中没有对应的记录,get()方法返回的是null.而load()方法出现异常ObjectNotFoundException<br>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性<br>29.Webservice是跨平台，跨语言的远程调用技术;它的通信机制实质就是xml数据交换;它采用了soap协议（简单对象协议）进行通信;Web service 可以将你的服务发布到互联网上让别人去调用，也可以调用别人发布的web service，和使用自己的代码一样.<br>157.接口和抽象类不能是final的.接口的方法都是public，可以不声明方法;抽象类可以不包含抽象方法，但是不能实例化;空接口：标记接口，<strong>Seriazliable</strong><br>158.abstract不能与final并列修饰同一个类;静态方法不能直接处理静态对象.<br>159.File类：FileReader()/FileWriter():继承自字节流;createNewFile/createTempFile();<br>160.线程安全的Map的实现:Map map = new ConcurrentHashMap();<br>Map map = Collections.synchronizedMap(new HashMap());<br>161.JVM:通过 ClassLoader 寻找和装载 class 文件;解释字节码成为指令并执行，提供 class 文件的运行环境;进行运行期间垃圾回收.OS和硬件交互.<br>162.对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式.ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递.<br>ThreadLocal继承Object，相当于没继承任何特殊的。ThreadLocal没有实现任何接口.ThreadLocal是采用哈希表的方式来为每个线程都提供一个变量的副本.<br>163.如果父类中的某个方法使用了synchronized关键字，而子类中也覆盖了这个方法，默认情况下<strong>子类中的这个方法并不是同步的</strong>，必须显示的在子类的这个方法中加上 synchronized关键字才可。当然，也可以在子类中调用父类中相应的方法，这样虽然子类中的方法并不是同步的，但子类调用了父类中的同步方法，也就相当子类方法也同步了。定义在接口中的方法默认是public的.<br>CGI内存开销高，<br>类种方法由县级:静态成员变量或静态代码块&gt;main方法&gt;非静态成员变量或非静态代码块&gt;构造方法<br>164.Jave ee:javax.servlet;javax.servlet.http<br>javax.servlet包中包含了7个接口,3个类和2个异常类,它们分别是:接口 :RequestDispatcher,Servlet,ServletConfig,ServletContext,ServletRequest,ServletResponse 和 SingleThreadModel. Use ServletConfig在init()方法中作为参数获取ServletContext;<br>java并发框架支持锁:读写锁;自旋锁(线程数增加时性能明显下降,不停在循环体内部执行);乐观锁;可重入锁(可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下 <strong>ReentrantLock和synchronized</strong>都是可重入锁);阻塞锁(和自旋锁对立)<br>165.jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。方法区使用元空间（MetaSpace）实现<br>167.结构型模式是描述如何将类对象结合在一起，形成一个更大的结构，结构模式描述两种不同的东西：类与类的实例。故可以分为类结构模式和对象结构模式。<br>168.<br>在GoF设计模式中，结构型模式有：<br>1.适配器模式 Adapter<br>适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。<br>2.桥接模式 Bridge<br>桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。<br>3.组合模式 Composite<br>组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。<br>4.装饰模式 Decorator<br>装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。<br>5.外观模式 Facade<br>外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。<br>外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。<br>6.享元模式 Flyweight<br>享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。.<br>享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。<br>7.代理模式 Proxy<br>为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。<br>169.CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程;Callable类的call()方法可以返回值和抛出异常;<br>170.Servlet与JSP九大内置对象的关系<br>JSP对象 怎样获得<br>out-&gt;response.getWriter<br>request -&gt;Service方法中的req参数<br>response -&gt;Service方法中的resp参数<br>session -&gt;request.getSession<br>application -&gt;getServletContext<br>exception -&gt;Throwable<br>page  -&gt;this<br>pageContext  -&gt;PageContext<br>Config -&gt;getServletConfig<br>171.LinkedBlockingQueue是一个可选有界队列，不允许null值;PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O(log(n))<br>172.Java于方法的调用采用的是栈帧（方法调用和方法执行），调用则入栈，完成之后则出栈。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-concept&quot;&gt;&lt;a href=&quot;#Java-concept&quot; class=&quot;headerlink&quot; title=&quot;Java concept&quot;&gt;&lt;/a&gt;Java concept&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>python subprocess module采坑</title>
    <link href="http://yoursite.com/2018/02/28/python-subprocess-module%E9%87%87%E5%9D%91.html"/>
    <id>http://yoursite.com/2018/02/28/python-subprocess-module采坑.html</id>
    <published>2018-03-01T02:50:24.000Z</published>
    <updated>2018-03-01T03:18:50.927Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Subprocess-Module"><a href="#Subprocess-Module" class="headerlink" title="Subprocess Module"></a>Subprocess Module</h2><p>今天使用subprocess给TA的课程cs354写了一点测试脚本，研究了一下subprocess这个module。原来上操作系统课程每天只是听说进程间通信是几种方式，Pipe管道、共享内存、Socket、消息队列MQ等等。从来没有用过Pipe,只使用过shared_memory(shmmem).今天用了一次才发现了大坑。<br><a id="more"></a><br>总的来说Subprocess定义了几个在子进程中执行一些其他命令的方式：<br>The subprocess module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes. This module intends to replace several older modules and functions:<br>os.system<br>os.spawn<em><br>os.popen</em><br>popen2.<em><br>commands.</em><br>The recommended way to launch subprocesses is to use the following convenience functions.<strong>subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False)</strong>,分别指定输入输出来源,返回returncode属性,shell=True是一个危险行为.Do not use stdout=PIPE or stderr=PIPE with this function as that can deadlock based on the child process output volume. Use Popen with the communicate() method when you need pipes.需要通信的时候需要使用Popen,避免直接使用Call.<br>subprocess.PIPE:Special value that can be used as the stdin, stdout or stderr argument to Popen and indicates that a pipe to the standard stream should be opened.<br>subprocess.STDOUT:Special value that can be used as the stderr argument to Popen and indicates that standard error should go into the same handle as standard output.<br>class <strong>subprocess.Popen</strong>(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0):在子进程中执行子程序,The shell argument (which defaults to False) specifies whether to use the shell as the program to execute. If shell is True, it is recommended to pass args as a string rather than as a sequence.<br>stdin, stdout and stderr specify the executed program’s standard input, standard output and standard error file handles, respectively. Valid values are <strong>PIPE, an existing file descriptor (a positive integer), an existing file object, and None.</strong> PIPE indicates that a new pipe to the child should be created. With the default settings of None, no redirection will occur; the child’s file handles will be inherited from the parent. Additionally, stderr can be STDOUT, which indicates that the stderr data from the child process should be captured into the same file handle as for stdout.<br>If cwd is not None, the child’s current directory will be changed to cwd before it is executed. 子进程切换到cwd目录执行.<br>Popen.communicate(input=None)和进程进行交互,向进程传递数据,比如C程序让你输参数.<br>Interact with process: Send data to stdin. Read data from stdout and stderr, until end-of-file is reached. Wait for process to terminate. The optional input argument should be a string to be sent to the child process, or None, if no data should be sent to the child.<br>communicate() returns a tuple (stdoutdata, stderrdata).<br>Note that if you want to send data to the process’s stdin, you need to <strong>create the Popen object with stdin=PIPE. Similarly, to get anything other than None in the result tuple, you need to give stdout=PIPE and/or stderr=PIPE too.</strong><br>Popen.kill():Kills the child.<br>Popen.wait():Wait for child process to terminate.<br>代码如下,自己定义的subcall子函数调用其他.c命令或者程序。Popen用的比较多的参数是第一个args,也就是你的管道要执行的命令参数，除此之外还有一个cwd_path是执行命令会切换到的绝对路径,<strong>当需要向文件写入pipe内容时，stdout需要给出文件句柄作为参数</strong>,<code>log = open(&#39;test&#39;,&#39;w&#39;);stdout = log</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def subcall(args, cwd_path, timeout=None, input=None, generate=False, file=None):</span><br><span class="line">    os.environ[&apos;LIBC_FATAL_STDERR_&apos;] = &apos;NOT_EMPTY&apos;</span><br><span class="line">    if generate == False:</span><br><span class="line">        with Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd_path) as proc:</span><br><span class="line">            try:</span><br><span class="line">                outs, errs = proc.communicate(timeout=timeout, input=input)</span><br><span class="line">            except TimeoutExpired:</span><br><span class="line">                proc.kill()</span><br><span class="line">                outs, errs = proc.communicate()</span><br><span class="line">            ret = proc.returncode</span><br><span class="line">    else:</span><br><span class="line">        with Popen(args, stdin=subprocess.PIPE, stdout=file, stderr=subprocess.PIPE, cwd=cwd_path) as proc:</span><br><span class="line">            try:</span><br><span class="line">                outs, errs = proc.communicate(timeout=timeout, input=input)</span><br><span class="line">            except TimeoutExpired:</span><br><span class="line">                proc.kill()</span><br><span class="line">                outs, errs = proc.communicate()</span><br><span class="line">            ret = proc.returncode</span><br><span class="line">    return outs, errs, ret</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Subprocess-Module&quot;&gt;&lt;a href=&quot;#Subprocess-Module&quot; class=&quot;headerlink&quot; title=&quot;Subprocess Module&quot;&gt;&lt;/a&gt;Subprocess Module&lt;/h2&gt;&lt;p&gt;今天使用subprocess给TA的课程cs354写了一点测试脚本，研究了一下subprocess这个module。原来上操作系统课程每天只是听说进程间通信是几种方式，Pipe管道、共享内存、Socket、消息队列MQ等等。从来没有用过Pipe,只使用过shared_memory(shmmem).今天用了一次才发现了大坑。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux knowledge</title>
    <link href="http://yoursite.com/2018/02/26/Linux-knowledge.html"/>
    <id>http://yoursite.com/2018/02/26/Linux-knowledge.html</id>
    <published>2018-02-27T05:44:53.000Z</published>
    <updated>2018-02-28T19:24:42.125Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Useful-command"><a href="#Useful-command" class="headerlink" title="Useful command"></a>Useful command</h2><p>df:查看磁盘使用情况<br>dd:convert and copy a file<br>top:查看CPU占用<br>du:estimate file space usage<br>tail -f:查看文件结尾信息<br>/etc/hosts 主机名到 IP 地址的映射关系的文件<br>/etc/resolv.conf DNS 服务的配置文件<br>/etc/gateways 建立动态路由需要用到的文件<br>clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等.clone()是可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。另外，clone()返回的是子进程的pid<br>select,pselect,FD_CLR,FD_ISSET,FD_SET,FD_ZERO - synchronous I/O<br>multiplexing<br>free查看内存整体的使用情况<br>cat /proc/meminfo查看内存更详细的情况<br>last:原来登陆的用户清单<br>可以查看当前系统的启动时间:w, top, uptime<br>cat /proc/meminfo:查看物理内存大小<br>ifconfig:配置本地回环地址,配置网卡的IP地址,激活网络适配器<br>硬链接删了能访问，软连接删了没了，能跨文件系统。<br>lprm 命令用于将一个工作由打印机贮列中移除<br><strong>lpq 命令用于查看一个打印队列的状态，该程序可以查看打印机队列状态及其所包含的打印任务。</strong><br>lpd 命令 是一个常驻的打印机管理程序，它会根据 /etc/printcap 的内容来管理本地或远端的打印机。<br><strong>lpr(line printer，按行打印)实用程序用来将一个或多个文件放入打印队列等待打印。</strong><br>将网卡激活不需要重新编译内核<br>netd表示Network守护进程. Netd负责跟一些涉及网络的配置，操作，管理，查询等相关的功能实现，比如，例如带宽控制（Bandwidth），流量统计，带宽控制，网络地址转换（NAT），个人局域网（pan），PPP链接，soft-ap，共享上网（Tether），配置路由表，interface配置管理.<br>vsftpd服务流量控制的参数:local_max_rate; anon_max_rate<br>init启动进程需要读取()配置文件:<strong>/etc/inittab</strong><br>whereis 可查询二进制文件(-b)、帮助文档(-m)、源程序（-s），无选项时，返回所有结果，-u(除上述三种的其它文件)<br>which   查看可执行文件的位置<br>whatis  查询命令有什么功能<br>apropos  搜索指定关键字的命令<br>cat /proc/interrupts查看中断<br>jobs 查看后台进程作业<br>fseek是库函数，lseek是系统调用<br>cp source des/filename:can rename the copied file<br><strong>nohup    在注销后使用  nohup  命令运行后台中的程序</strong></p><h2 id="Inode可以被多个文件使用"><a href="#Inode可以被多个文件使用" class="headerlink" title="Inode可以被多个文件使用"></a>Inode可以被多个文件使用</h2><p>Unix/Linux系统允许，多个文件名指向同一个inode号码。这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。 除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的”软链接”（soft link）或者”符号链接（symbolic link）。<br>所有加载的文件系统在/etc/mtab中得到反映。<br>目录在文件系统中也是以文件形式存在</p><h2 id="Spinlock"><a href="#Spinlock" class="headerlink" title="Spinlock"></a>Spinlock</h2><p>spinlock在多处理器多线程环境的场景中有很广泛的使用，一般要求使用spinlock的临界区尽量简短，这样获取的锁可以尽快释放，以满足其他忙等的线程。Spinlock和mutex不同，spinlock不会导致线程的状态切换(用户态-&gt;内核态)，但是spinlock使用不当(如临界区执行时间过长)会导致cpu busy飙高。</p><h2 id="CPU负载"><a href="#CPU负载" class="headerlink" title="CPU负载"></a>CPU负载</h2><p>数字越小越好，可以通过TOP命令查看，可以通过uptime查看</p><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>Linux系统中，已经将DHCP服务器架设好，客户端的网络接口eth0，可以通过（ ）命令获得服务器分配的IP地址：dhclient,ifdown eth0；ifup eth0<br>TCP、UDP可以绑定同一端口进行通信，取决于数据包的协议类型决定使用哪种协议。<br>网络write返回n&gt;0表示已经发送nbyte<br>硬链接仅仅删除文件名，inode没删，不能链接目录；<br>查看本机路由情况:<strong>route/netstat</strong><br>route命令用来显示目前本机路由表的内容，并且还可以针对路由表中的记录来进行相应的添加、删除或修改等操作。<br><strong>ifconfig命令用来来检测和设置本机的网络接口。</strong><br>ping命令用来检测两部主机之间的传输信道是否畅通，或远程主机是否正常<br>netstat命令用来查看主机的连接状态<br>DHCP服务器能提供的服务包括：<strong>提供DNS、网关信息；为特定客户机提供固定IP地址；为主机提供动态的IP地址</strong></p><h2 id="Select-Epoll"><a href="#Select-Epoll" class="headerlink" title="Select/Epoll"></a>Select/Epoll</h2><p>linux的I/O复用接口select和epoll.<br>select 和 epoll效率差异的原因：select采用轮询方式处理连接，epoll是触发式处理连接。<br>Select:<br>1.Socket数量限制：该限制可操作的Socket数由FD_SETSIZE决定，内核默认32*32=1024.<br>2.操作限制：通过遍历FD_SETSIZE(1024)个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。<br>poll使用pollfd结构来存储fd，突破了select中描述符数目的限制。<br>与select的后两点类似，poll仍然需要将pollfd数组拷贝到内核空间，之后依次扫描fd的状态，整体复杂度依然是O（n）的，在并发量大的情况下服务器性能会快速下降。<br>Epoll<br>1.Socket数量无限制：该模式下的Socket对应的fd列表由一个数组来保存，大小不限制（默认4k）。<br>2.操作无限制：基于内核提供的反射模式，有活跃Socket时，内核访问该Socket的callback，不需要遍历轮询。但当所有的Socket都活跃的时候，所有的callback都被唤醒，会导致资源的竞争。既然都是要处理所有的Socket，那么遍历是最简单最有效的实现方式。<br>服务器的特点是经常维护着大量连接，但其中某一时刻读写的操作符数量却不多。epoll先通过epoll_ctl注册一个描述符到内核中，并一直维护着而不像poll每次操作都将所有要监控的描述符传递给内核；在描述符读写就绪时，通过回掉函数将自己加入就绪队列中，之后epoll_wait返回该就绪队列。也就是说，epoll基本不做无用的操作，时间复杂度仅与活跃的客户端数有关，而不会随着描述符数目的增加而下降。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>1.Linux执行ls，会引起哪些系统调用：read,fork,execv</p><h2 id="nagle算法"><a href="#nagle算法" class="headerlink" title="nagle算法"></a>nagle算法</h2><p>2.在linux编程中，以下哪个TCP的套接字选项与nagle算法的开启和关闭有关？<br>TCP_NODELAY<br>3.Nagle算法的规则：<br>（1）如果包长度达到MSS，则允许发送；<br>（2）如果该包含有FIN，则允许发送；<br>（3）设置了TCP_NODELAY选项，则允许发送；<br>（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；<br>（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。<br>Nagle算法只允许一个未被ACK的包存在于网络，它并不管包的大小，因此它事实上就是一个扩展的停-等协议，只不过它是基于包停-等的，而不是基于字节停-等的。Nagle算法完全由TCP协议的ACK机制决定，这会带来一些问题，比如如果对端ACK回复很快的话，Nagle事实上不会拼接太多的数据包，虽然避免了网络拥塞，网络总体的利用率依然很低。<br>Nagle算法是silly window syndrome(SWS)预防算法的一个半集。SWS算法预防发送少量的数据，Nagle算法是其在发送方的实现，而接收方要做的是不要通告缓冲空间的很小增长，不通知小窗口，除非缓冲区空间有显著的增长。这里显著的增长定义为完全大小的段（MSS）或增长到大于最大窗口的一半。<br>注意：BSD的实现是允许在空闲链接上发送大的写操作剩下的最后的小段，也就是说，当超过1个MSS数据发送时，内核先依次发送完n个MSS的数据包，然后再发送尾部的小数据包，其间不再延时等待。（假设网络不阻塞且接收窗口足够大）<br>举个例子，比如之前的blog中的实验，一开始client端调用socket的write操作将一个int型数据（称为A块）写入到网络中，由于此时连接是空闲的（也就是说还没有未被确认的小段），因此这个int型数据会被马上发送到server端，接着，client端又调用write操作写入‘\r\n’（简称B块），这个时候，A块的ACK没有返回，所以可以认为已经存在了一个未被确认的小段，所以B块没有立即被发送，一直等待A块的ACK收到（大概40ms之后），B块才被发送。整个过程如图所示：<br>这里还隐藏了一个问题，就是A块数据的ACK为什么40ms之后才收到？这是因为TCP/IP中不仅仅有nagle算法，还有一个TCP确认延迟机制 。当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假设为t），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。在我之前的时间中，t大概就是40ms。这就解释了为什么’\r\n’（B块）总是在A块之后40ms才发出。<br>当然，TCP确认延迟40ms并不是一直不变的，TCP连接的延迟确认时间一般初始化为最小值40ms，随后根据连接的重传超时时间（RTO）、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。另外可以通过设置TCP_QUICKACK选项来取消确认延迟。</p><h2 id="进程类型"><a href="#进程类型" class="headerlink" title="进程类型"></a>进程类型</h2><p>交互进程——由一个shell启动的进程。交互进程既可以在前台运行，也可以在后台运行。<br>批处理进程——这种进程和终端没有联系，是一个进程序列。<br>监控进程（也称守护进程）——Linux系统启动时启动的进程，并在后台运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Useful-command&quot;&gt;&lt;a href=&quot;#Useful-command&quot; class=&quot;headerlink&quot; title=&quot;Useful command
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Database-relation-algebra</title>
    <link href="http://yoursite.com/2018/02/26/Database-relation-alebra.html"/>
    <id>http://yoursite.com/2018/02/26/Database-relation-alebra.html</id>
    <published>2018-02-26T16:49:33.000Z</published>
    <updated>2018-02-27T05:55:45.541Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="RA"><a href="#RA" class="headerlink" title="RA"></a>RA</h2><p>Declarative language/Procudual language<br>RA：operands,operator<br><a id="more"></a><br>select/projection can be composited together;projection will select only those distinct tuples, which is equivalant to select distinct column name.<br>cross production：combines 2 database together.;will match automatically on 1 attribute.<br>set difference:<br>union:both relation mush have the same schema(attr形式相同,will filter duplicate rows)<br>renaming:pa1,a2(name):自己的relation和自己join的时候需要进行一种区分.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RA&quot;&gt;&lt;a href=&quot;#RA&quot; class=&quot;headerlink&quot; title=&quot;RA&quot;&gt;&lt;/a&gt;RA&lt;/h2&gt;&lt;p&gt;Declarative language/Procudual language&lt;br&gt;RA：operands,operator&lt;br&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Spring-detail-knowledge</title>
    <link href="http://yoursite.com/2018/02/25/Spring-detail-knowledge.html"/>
    <id>http://yoursite.com/2018/02/25/Spring-detail-knowledge.html</id>
    <published>2018-02-26T05:47:10.000Z</published>
    <updated>2018-02-26T05:59:27.677Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>2.方便的事务管理: Spring的声明式事务管理力度是类级别,错。spring现在只支持方法级别的织入点，域级别的还没有实现。<br>3.Spring提供的DAO(数据访问对象)支持主要的目的是便于以标准的方式使用不同的数据访问技术。<br>4.异常包装:Spring能够包装Hibernate异常，把它们从CheckedException变为RuntimeException; 开发者可选择在恰当的层处理数据中不可恢复的异常，从而避免烦琐的 catch/throw 及异常声明<br>5.Spring提供的DAO支持了JDBC、JDO和Hibernate<br>6.Spring提供的DAO(数据访问对象)支持主要的目的是<strong>便于以标准的方式使用不同的数据访问技术</strong>。 简化 DAO 组件的开发。 Spring提供了一套抽象DAO类供你扩展。这些抽象类提供了一些方法，用来简化代码开发。 IoC 容器的使用，提供了 DAO 组件与业务逻辑组件之间的解耦。所有的 DAO 组件，都由容器负责注入到业务逻辑组件中，其业务组件无须关心 DAO 组件的实现。 面向接口编程及 DAO 模式的使用，提高了系统组件之间的解耦，降低了系统重构的成本。 方便的事务管理: Spring的声明式事务管理力度是方法级。 异常包装:Spring能够包装Hibernate异常，把它们从CheckedException变为RuntimeException; 开发者可选择在恰当的层处理数据中不可恢复的异常，从而避免烦琐的 catch/throw 及异常声明。<br>7.spring事务可以分为编程式事务和声明式事务<br>8.spring提供了一个事务的接口 PaltformTractionManager接口，针对不同的事务，spring进行了不同的实现<br>声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码<br>1.Spring中涉及到事务管理的API有100多个，核心的只有三个： TransactionDefinition、PlatformTransactionManager、TransactionStatus。所谓事务管理，其实就是“按照给定的事务规则来执行提交或者回滚操作”。“给定的事务规则”就是用 TransactionDefinition 表示的，“按照……来执行提交或者回滚操作”便是用 PlatformTransactionManager 来表示，而 TransactionStatus 用于表示一个运行着的事务的状态。<br>2.TransactionDefinition， 该接口在前面已经介绍过，它用于定义一个事务。它包含了事务的静态属性，比如：事务传播行为、超时时间等等。Spring 为我们提供了一个默认的实现类：DefaultTransactionDefinition，该类适用于大多数情况。如果该类不能满足需求，可以通过实现 TransactionDefinition 接口来实现自己的事务定义。<br>3.PlatformTransactionManager  用于执行具体的事务操作。<br>Public interface PlatformTransactionManager{</p><p>   TransactionStatus getTransaction(TransactionDefinition definition)  throws TransactionException;</p><p>   void commit(TransactionStatus status)throws TransactionException;</p><p>   void rollback(TransactionStatus status)throws TransactionException;</p><p>}<br>根据底层所使用的不同的持久化 API 或框架，PlatformTransactionManager 的主要实现类大致如下：<br>DataSourceTransactionManager ：适用于使用JDBC和iBatis进行数据持久化操作的情况。<br>HibernateTransactionManager ：适用于使用Hibernate进行数据持久化操作的情况。<br>JpaTransactionManager ：适用于使用JPA进行数据持久化操作的情况。<br>另外还有JtaTransactionManager 、JdoTransactionManager、JmsTransactionManager等等。<br>编程式事务需要你在代码中直接加入处理事务的逻辑,可能需要在代码中显式调用beginTransaction()、commit()、rollback()等事务管理相关的方法,如在执行a方法时候需要事务处理,你需要在a方法开始时候开启事务,处理完后。在方法结束时候,关闭事务. 声明式的事务的做法是在a方法外围添加注解或者直接在配置文件中定义,a方法需要事务处理,在spring中会通过配置文件在a方法前后拦截,并添加事务. 二者区别.编程式事务侵入性比较强，但处理粒度更细. 相当于一个是手动事务，另一个是系统自动事务。 编程试事务就是需要手工写代码提交事务，回滚事务等。 声明性事务就是在配置文件里面定义一下什么时候需要事务，到时候系统会自动commit，出异常了自动rollback，不需要在代码里面写commit或者rollback。</p><p>spring mvc 和struts2的区别： 1.spring mvc是基于方法的设计，而struts2是基于类的设计。 2.struts2有以自己的interceptor机制，spring mvc用的是独立的AOP方式。 3.spring mvc的方法之间基本上独立的，独享request response数据，struts2所有Action变量是共享的。 4.机制：spring mvc的入口是servlet，而struts2是filter。 5.性能：spring会稍微比struts快。 spring mvc是基于方法的设计 ， 而sturts是基于类 ， 每次发一次请求都会实例一个action，每个action都会被注入属性，而spring基于方法，粒度更细<br>8.Struts SpringMVC对比<br>参数传递：struts是在接受参数的时候，可以用属性来接受参数，这就说明参数是让多个方法共享的。<br>设计思想上： struts更加符合oop的编程思想 ， spring就比较谨慎，在servlet上扩展。 8.intercepter(拦截器)的实现机制：struts有以自己的interceptor机制， spring mvc用的是独立的AOP方式 。<br>9.Spring通过对AOP的支持，借助log4j等Apache开源组件实现了日志系统。</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>1.基于Servlet API如何实现转向时不在地址栏中显示转向后的地址？forward ( )<br>7.运用javax.servlet.RequestDispatcher接口的forward方法请求转发<br>8.Spring框架中的核心思想包括DI,IOC,AOP<br>9.Spring数据库连接池:DBCP数据源;C3P0数据源;Spring的数据源实现(DriverManagerDataSource);获取JNDI数据源<br>10..Servlet只包含了init方法<br><strong>doGet和doPost是HttpServlet中的方法；forward是RequestDispatcher的方法</strong> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h2&gt;&lt;p&gt;2.方便
      
    
    </summary>
    
    
      <category term="Java EE" scheme="http://yoursite.com/tags/Java-EE/"/>
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>OS practice problem summary</title>
    <link href="http://yoursite.com/2018/02/25/OS-practice-problem-summary.html"/>
    <id>http://yoursite.com/2018/02/25/OS-practice-problem-summary.html</id>
    <published>2018-02-26T04:31:14.000Z</published>
    <updated>2018-02-27T19:56:59.458Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>1.系统的主要功能有:<br>虚拟存储管理、处理机管理、进程调度、文件系统<br>2.通道控制设备控制器，设备控制器控制设备<br>3.在多道程序系统执行，一般情况下，每个程序执行完毕需要的时间（）大于单道系统时间<br><a id="more"></a><br>4.UNIX是<strong>多道批处理系统</strong><br>5.Unix操作系统允许用户在<strong>汇编语言</strong>上使用系统调用。<br>6.共享设备不需要用户安装设备驱动程序。<br>7.在 UNIX 中，文件系统和设备驱动程序之间的接口是<strong>DCT设备控制表</strong><br>8.SJF会引起Starvation<br>9.超级用户（管理员、特权用户）可以使用特权指令。错，是提供给操作系统系统态的<br>10.进程是资源分配的基本单位，<strong>线程是资源调度的基本单位</strong><br>11.进程间通信的方式:共享内存;消息传递;系统管道;同步(互斥锁,条件变量,读写锁,文件和记录锁,Posix和System V信号灯) ;临界区用于线程<br>12.Linux内核默认支持的文件格式:ext3;ext2;ext4;xfs;ufs<br>13.进程之间存在直接制约关系(即同步问题)和间接制约关系(即互斥问题)<br>14.多个进程怎样共享一个监听端口？fork共享监听套接字<br>15.分段内存管理，逻辑地址是二维地址<br>16.在 Windows 的 FAT 文件系统中，对磁盘空闲空间的管理采用<strong>位示图法</strong><br>17.在设备管理中，逻辑设备表（ LUT ）的作用是在物理设备和逻辑设备之间建立对应关系<br>18.并发是指多个请求向服务器同时请求，服务器的响应过程是依次响应，或者轮转响应的；并行是多个请求向多个服务器，各自服务各自的请求(类似多处理GPU)<br>19.缓存是为了提高并行操作，提高CPU和设备之间的并行程度<br>20.线程提高了不同执行程序间的通信效率<br>21.无结构文件的含义是<strong>流式文件</strong>.流式文件中构成文件的基本单位是字符，流式文件是有序字符的集合，其长度为该文件所包含的字符个数，所以又称为字符流文件。流式文件无结构，且管理简单，用户可以方便地对其进行操作。源程序、目标代码等文件属于流式文件。<strong>UNIX系统采用的是流式文件结构。</strong>记录式文件:一群记录的集合，<br>22.降低进程优先级的合理时机是:时间片用完，RR<br>23.进程对管道进行读操作和写操作都可以被<strong>阻塞</strong>.<strong>管道是 单向的、先进先出的 ，它把一个进程的输出和另一个进程的输入连接在一起。一个进程（写进程）在管道的 尾部写入数据 ，另一个进程（读进程）从管道的 头部读出数据 。</strong><br>24.哪一个不属于活动头硬盘的存取访问时间？旋转延迟时间+寻道时间+传送时间<br>25.文件的逻辑结构:记录式，流式文件;物理结构:连续结构,串联结构,索引结构<br>26.死锁是指因相互竞争资源使得系统中有多个阻塞进程的情况;若系统中并发运行的进程和资源之间满足互斥条件、占有且申请、不可抢占和环路条件，则可判定系统中发生了死锁<br>27.向量中断由硬件形成向量地址，再由向量地址找到中断服务程序入口地址<br>28.输出字符是系统调用。两个合作进程，无法利用<strong>全局变量</strong>传递信息,都是自己的东西。<br>29.线程切换进程可能切换，要看下一个被调度的线程和当前线程是否属于同一进程。如果不属于才切换页表，更换进程用户空间，否则只是从事一些线程级别工作，不会切换进程的<br>30.<strong>共享设备在同一时刻只能有一个作业调用。</strong><br>31.对进程间互斥的使用临界资源，进程可以<strong>互斥的进入各自的同类资源临界区</strong><br>32.银行家算法是著名的<strong>死锁避免算法</strong>，避免死锁并不是事先采取某种限制措施破坏死锁的必要条件，而是再资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁.<br>33.对进程来说，其虚拟内存的大小不受物理内存大小的限制.<strong>线程有自己的栈，没有堆</strong><br>34.程序=数据结构+算法<br>35.在虚拟存储器中为了提高主存的命中率，可以采取的措施是<strong>增大主存容量</strong><br>36.显示磁盘文件目录的DOS命令DIR。一个英文字符2个ASCII码,DOS文件目录是树形结构。<br>37.下列哪些因素不会限制Linux服务器并发连接数?<strong>系统网卡数量</strong><br>系统内存大小<br>系统网卡数量<br>系统最大文件句柄数量<br>系统IP地址数量<br>38.网络：环形拓扑，星星拓扑，总线拓扑<br>39.<strong>局部static</strong>变量的可见性与生存期不一致。<br>40.接口可以包含方法、属性、索引器和事件，不能包含共有私有变量。<br>41.同一时刻只能有一个部件占用总线发送信息，但可以有多个部件通过总线接收信息<br>42.DNS用来解析域名地址和IP地址。<br>43.方法覆盖返回值类型可以小于父类。<br>shmget获得shared memory,共享内存并没有同步机制<br>44.银行家算法是一种最有代表性的避免死锁的算法。又被称为“资源分配拒绝”法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。<br>45.线程不能跨机器迁移，进程适合在SMP机器上迁移。<br>47.Event、Semaphore、Mutex是内核对象，能够跨进程使用，Critical Section不能跨进程，只能实现线程内互斥(线程同步)<br>48.可重入函数对全局变量才需要互斥量保护。可重入函数不可以调用不可重入函数<br>49.轮询调度优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度.抢占式调度实现相对较复杂.Preempted/unpreempted<br>50.<strong>run()方法用来执行线程体中具体的内容</strong><br>51.volatile变量具有synchronized的可见性特性，<strong>但是不具备原子特性。</strong><br>start()方法用来启动线程对象，使其进入就绪状态<br>sleep()方法用来使线程进入睡眠状态<br>suspend()方法用来使线程挂起，要通过resume()方法使其重新启动<br>52.当线程企图访问临界资源时，先会查看该临界资源当前是否已被加锁，如果没有被加锁，则对该临界资源加锁，并进入该同步块或方法，加锁后，其他线程也就无法访问该临界资源了。所以判定获取了一个内部锁的标准为：进入该同步区域。获取内部锁的标准，进入同步区域。<br>53.页式管理:内碎片，段式管理:外碎片<br>pwd是环境变量/用户登录系统时，bash首先执行/etc/profile配置文件和/etc/profile.d/目录下的配置文件，这些配置文件对所有用户都有效<br>54.shutdown    关机, ctrl+z暂停，ctrl+c终止<br>55.一台主机要实现通过局域网与另一个局域网通信，需要做的工作是？<br><strong>定义一条本机指向所在网络网关的路由</strong><br>56.属于网络操作系统的是？Unix, Linux,WINDOWS NT, NETWARE 4.11,LAN MANGER 4.</p><h2 id="并发经典问题"><a href="#并发经典问题" class="headerlink" title="并发经典问题"></a>并发经典问题</h2><p>使用fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。<br>子进程与父进程的区别在于：<br><strong>1、父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）</strong><br>2、各自的进程ID和父进程ID不同<br>3、子进程的未决告警被清除；<br>4、子进程的未决信号集设置为空集。<br>2.用户线程和内核线程的调度都需要经过内核态。错。用户线程在用户态</p><h2 id="Java并发编程的同步机制"><a href="#Java并发编程的同步机制" class="headerlink" title="Java并发编程的同步机制"></a>Java并发编程的同步机制</h2><p>A，Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>B，CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。<br>C，直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</p><h2 id="Database-transaction理论"><a href="#Database-transaction理论" class="headerlink" title="Database transaction理论"></a>Database transaction理论</h2><p>脏读：就是指当一个事务对数据进行了修改但还没有提交到数据库时，另一个事务访问并使用了这个数据。<br>不可重复读：在一个事务内两次读数据之间，第二个事务访问该数据并进行了修改。<br>丢失修改：两个事务读入同一数据并修改，T2提交的结果破坏了T1提交的结果。例如T1读A修改为A-1，T2也读A修改为A-1（实际上应该是读A-1，修改 为A-2）<br>幻影读：同一事务在两个不同的时间段执行相同的查询条件得到的结果不一致。<br>注意区分：<br>不可重复读的重点是修改<br>同样的条件,你读取过的数据,再次读取出来发现值不一样了<br>幻读的重点在于新增或者删除<br>同样的条件, 第 1 次和第 2 次读出来的记录数不一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题总结&quot;&gt;&lt;a href=&quot;#问题总结&quot; class=&quot;headerlink&quot; title=&quot;问题总结&quot;&gt;&lt;/a&gt;问题总结&lt;/h2&gt;&lt;p&gt;1.系统的主要功能有:&lt;br&gt;虚拟存储管理、处理机管理、进程调度、文件系统&lt;br&gt;2.通道控制设备控制器，设备控制器控制设备&lt;br&gt;3.在多道程序系统执行，一般情况下，每个程序执行完毕需要的时间（）大于单道系统时间&lt;br&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>pandas details</title>
    <link href="http://yoursite.com/2018/02/24/pandas-details.html"/>
    <id>http://yoursite.com/2018/02/24/pandas-details.html</id>
    <published>2018-02-25T03:06:49.000Z</published>
    <updated>2018-02-27T02:24:43.217Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Classical-usage-of-Pandas"><a href="#Classical-usage-of-Pandas" class="headerlink" title="Classical usage of Pandas"></a>Classical usage of Pandas</h2><a id="more"></a><p>Series &amp; DataFrame are most important elements in pandas. df[‘col’] will return a Series with col as column name; can assign column name and index name with df.index/df.columns = ;can select using integer index like df.iloc[a,b] or using name value like df.loc[‘index1’,’col1’], can also using filter condition such as df.loc[df[‘col’] == val, :]</p><h2 id="Use-a-single-ceil-to-store-a-list"><a href="#Use-a-single-ceil-to-store-a-list" class="headerlink" title="Use a single ceil to store a list"></a>Use a single ceil to store a list</h2><p>If you want to uses a single ceil to store a whole list, don’t use .iloc which may cause Valueerr, caonsider using <strong>at(m,n)</strong>, which need column name as find params. Can also use iat(m,n). Actually, dataframe ca definitly used to store Series &amp;&amp; Dataframe in a single cell.</p><h2 id="Merge-amp-Join"><a href="#Merge-amp-Join" class="headerlink" title="Merge &amp; Join"></a>Merge &amp; Join</h2><p>Can merge 2/ more dataframe together using the list/dict as params.<br>frame = [df1,df2,df3], which all has the same index and column, implied the same structure.<br>result = pd.concat(frame)<br>df1.append(index, axis = 0), concat along the index dimension, can also get 2 matrix together.<br>pandas has full-featured, high performance in-memory join operations idiomatically very similar to relational databases like SQL. These methods perform significantly better (in some cases well over an order of magnitude better) than other open source implementations (like base::merge.data.frame in R). The reason for this is careful algorithmic design and internal layout of the data in DataFrame.<br>Useful tips when using concat, the <strong>index</strong> and the columns will all be kept, if you want to regenerate the range num index for concat dataframe, using <strong>ignore_index</strong> when call concat. newdf = pd.concat(list, ignore_index = True).</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Classical-usage-of-Pandas&quot;&gt;&lt;a href=&quot;#Classical-usage-of-Pandas&quot; class=&quot;headerlink&quot; title=&quot;Classical usage of Pandas&quot;&gt;&lt;/a&gt;Classical usage of Pandas&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux memory management</title>
    <link href="http://yoursite.com/2018/02/19/Linux-memory-management.html"/>
    <id>http://yoursite.com/2018/02/19/Linux-memory-management.html</id>
    <published>2018-02-19T14:39:45.000Z</published>
    <updated>2018-02-19T15:04:23.622Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Memory-management-in-Linux-Buddy-algorithms"><a href="#Memory-management-in-Linux-Buddy-algorithms" class="headerlink" title="Memory management in Linux(Buddy algorithms)"></a>Memory management in Linux(Buddy algorithms)</h2><p>Memory allocators have two distinct tasks. First, the memory allocator uses the <strong>sbrk() system call</strong> to ask the operating <a id="more"></a>system to expand the heap segment of the its virtual address space. However in the code we’ve provided, we use <strong>mmap()</strong> to simulate a process’s heap in the memory-mapped segment. Second, the memory allocator manages this memory <strong>by maintaining the internal structure of the heap including tracking the size and status of each block.</strong> When the process makes a request for heap memory, the allocator searches its list of heap blocks for one that is <strong>large enough to satisfy the request</strong>. The chosen block may be split into two smaller ones before having its status set to allocated. Later when process frees memory, the allocator changes the block’s status to freed and may <strong>coalesce it with free neighbors to make larger blocks.</strong></p><p>This memory allocator is usually provided as part of a standard library rather than being part of the operating system. Thus, the memory allocator operates entirely within the virtual address space of a single process and knows nothing about which physical memory pages have been allocated to this process or the mapping from virtual addresses to physical addresses.(<strong>Virtulization</strong>)<br>The C programming language defines its allocator with the functions malloc() and free() found in “stdlib.h”.</p><h2 id="How-free-amp-malloc-works"><a href="#How-free-amp-malloc-works" class="headerlink" title="How free &amp; malloc works"></a>How free &amp; malloc works</h2><p>Memory management unit control a list of memory and mark each block of memory as used/free, besides, it maintains a header of memory block and alloc memory using this pointer.<br>Note that for improved performance, Mem_Init(int sizeOfRegion) rounds up the amount memory requested to the nearest page so it is possible that <strong>more memory might be allocated than originally specified by sizeOfRegion.</strong> All of this memory is initialized as the first and only block in the free list to be used by your allocator and is accessed via first_block, which will be pointing to that block’s header. This is the beginning of the implicit free list that your allocator uses to allocate blocks via Mem_Alloc() calls. Your allocator will need to divide this block into smaller pieces as memory is requested.<br>Note, we won’t request more memory from the OS than what was originally allocated by Mem_Init().</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Memory-management-in-Linux-Buddy-algorithms&quot;&gt;&lt;a href=&quot;#Memory-management-in-Linux-Buddy-algorithms&quot; class=&quot;headerlink&quot; title=&quot;Memory management in Linux(Buddy algorithms)&quot;&gt;&lt;/a&gt;Memory management in Linux(Buddy algorithms)&lt;/h2&gt;&lt;p&gt;Memory allocators have two distinct tasks. First, the memory allocator uses the &lt;strong&gt;sbrk() system call&lt;/strong&gt; to ask the operating
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Database design sumary</title>
    <link href="http://yoursite.com/2018/02/18/Database-design-summary.html"/>
    <id>http://yoursite.com/2018/02/18/Database-design-summary.html</id>
    <published>2018-02-18T23:53:11.000Z</published>
    <updated>2018-02-26T16:48:04.007Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Composite-key"><a href="#Composite-key" class="headerlink" title="Composite key"></a>Composite key</h2><a id="more"></a><p>I design a database system with auction based. In this system, one kind of item can have multiple category and one category can possess multiple items, thus create a independent table which uses composite primary key. Notice that <strong>primary key</strong> can have multiple columns, not only 1 column. This applies to all many-to-many relationship.</p><h2 id="Functional-Dependency"><a href="#Functional-Dependency" class="headerlink" title="Functional Dependency"></a>Functional Dependency</h2><p>Use FD &amp; FD Closure to determine good DB and make normalization. Not always make BCNF decompotion. When you make a composition, the attributes are splitted. <strong>FD in 1 attr set only refer to all attr are contained in this datasets.</strong>BCNF decompisition will splitted into all trivial &amp;&amp; super key datasets.<br>BCNF after decompotion all nontrival FD/ all FD are in super key</p><h2 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h2><p>BCNF implies 3NF.<br>Relation R is in 3NF, if FD X-&gt;A, is trival FD, X is super key, <strong>A is part of some key of R.</strong>Decomposition into 3NF is always feasible. <strong>Lossless join and property preserving.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Composite-key&quot;&gt;&lt;a href=&quot;#Composite-key&quot; class=&quot;headerlink&quot; title=&quot;Composite key&quot;&gt;&lt;/a&gt;Composite key&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Linux-screen-command</title>
    <link href="http://yoursite.com/2018/02/17/Linux-screen-command.html"/>
    <id>http://yoursite.com/2018/02/17/Linux-screen-command.html</id>
    <published>2018-02-17T16:41:53.000Z</published>
    <updated>2018-02-19T00:52:24.508Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="Screen-command-for-terminal"><a href="#Screen-command-for-terminal" class="headerlink" title="Screen command for terminal"></a>Screen command for terminal</h3><p>Screen is a full-screen window manager that multiplexes a physical terminal between several processes, typically interactive shells. See <a href="https://www.gnu.org/software/screen/manual/screen.html#Getting-Started" target="_blank" rel="noopener">link</a>.<br>When screen is called, it creates a single window with a shell in it (or the specified command) and then gets out of your way so that you can use the program as you normally would. Then, at any time, you can create new (full-screen) windows with other programs in them (including more shells), kill the current window, view a list of the active windows, turn output logging on and off, copy text between windows, view the scrollback history, switch between windows, etc. All windows run their programs completely independent of each other. <strong>Programs continue to run when their window is currently not visible and even when the whole screen session is detached from the user’s terminal.</strong></p><h2 id="grep-only-shows-file-name"><a href="#grep-only-shows-file-name" class="headerlink" title="grep only shows file name"></a>grep only shows file name</h2><p>Using <code>grep -l &quot;pattern&quot;</code><br>find file by filename, <code>find -name name.exe</code></p><h2 id="Java-invoke"><a href="#Java-invoke" class="headerlink" title="Java invoke"></a>Java invoke</h2><p><code>java -jar file.jar -v r1 -r rtable.r1 -a arp_cache</code> invoke the corresponding jar file’s main methods, the remain params are passed into the main methods of programs.<br>first params is the file invoked.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;Screen-command-for-terminal&quot;&gt;&lt;a href=&quot;#Screen-command-for-terminal&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Computer-network-week5</title>
    <link href="http://yoursite.com/2018/02/16/Computer-Network-week5.html"/>
    <id>http://yoursite.com/2018/02/16/Computer-Network-week5.html</id>
    <published>2018-02-16T23:39:35.000Z</published>
    <updated>2018-02-17T18:45:45.248Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>IP defines a service model to solve heterogenity, an important part is the global addressing scheme, which enables 2 nodes uniquely identify each other. </p><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>In virtual circuit, only the connection request packets need routing, for datagrams all packets need routing.<br>开始是路由过程，学习网络结构并记录到路由表里面，后面每个包的转发使用转发表，使用最长prefix Trie算法。<br>Forwarding consists of taking a packet, looking at its destination address, consulting a table, and sending the packet in a direction determined by that table.The entry usually includes <strong>output interface &amp;&amp; its corresponsding MAC address</strong>. We saw several examples of forwarding in the preceding section. Routing is the process by which forwarding tables are built.<br><strong>Forwarding table</strong> contains Mapping from nerwork prefix to the next hop in the network and the Ethernet address.<br><strong>Routing table</strong> routing alrorithms precursor to build forwarding table.<br>两种查找表是否需要不同的实现？<br>the forwarding table needs to be structured to optimize the process of looking up an address when forwarding a packet, while the routing table needs to be optimized for the purpose of calculating changes in topology. </p><h2 id="intradomain-routing-protocols-interior-gateway-protocols-IGPs"><a href="#intradomain-routing-protocols-interior-gateway-protocols-IGPs" class="headerlink" title="intradomain routing protocols, interior gateway protocols (IGPs)"></a>intradomain routing protocols, interior gateway protocols (IGPs)</h2><p>所有router存在同一个administrative control下。<br>静态方法的缺陷：<br>1.处理不了节点failure<br>2.考虑不到新的nodes、links<br>3.edge cost can’t change</p><h3 id="Distance-vector"><a href="#Distance-vector" class="headerlink" title="Distance vector"></a>Distance vector</h3><p>Each node maintains a vector to all other nodes and send it to its neighbors. Each node knows the cost to its neighbor initially.通知相邻接点自己的距离向量，与当前向量比较，进行更新。最终每个节点也仅仅知道自己的路由信息(distributed).periodic updates/trigger updates.<br>实现方法：<br>周期函数持续扫描，超过时间将entry从表中移除。entry包含下一跳，目标地址，TTL元素。每次reconfirm收到neighbor的消息，重置这个entry的TTL。(利用neighbor的cost进行更新，每次比较cost+1)</p><h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><p>RIP is the canonical example of a routing protocol built on the distance-vector algorithm just described. Many unix system based on this.<br>和理想距离向量的区别:<br>Rather than advertising the cost of reaching other routers, the routers advertise the <strong>cost of reaching networks.</strong>The majority of the packet is taken up with haddress, mask, distancei triples.  RIP can only run on fairly small network, optimize minimum hops, as each segment with cost of 1.</p><h3 id="Link-state"><a href="#Link-state" class="headerlink" title="Link state"></a>Link state</h3><p>Assumption:Every node knows how to reach its directly connected neighbors, and if we make sure that the totality of this knowledge is disseminated to every node, then every node will have enough knowledge of the network to build a complete map of the network. (从局部最优推广到全局最优). 2 mechanism: <strong>reliable dissemination of link-state information, and the calculation of routes from the sum of all the accumulated link-state knowledge.</strong></p><h4 id="Reliable-flooding"><a href="#Reliable-flooding" class="headerlink" title="Reliable flooding"></a>Reliable flooding</h4><p>each node creates an update packet, also called a <strong>linkstate packet (LSP)</strong>, which contains the following information:</p><ul><li>The ID of the node that created the LSP</li><li>A list of directly connected neighbors of that node, with the cost of the link to each one</li><li>A sequence number</li><li>A time to live for this packet</li></ul><h3 id="Summary-of-difference"><a href="#Summary-of-difference" class="headerlink" title="Summary of difference"></a>Summary of difference</h3><p>In distance-vector, each node talks only to its directly connected neighbors, but it tells them everything it has learned (i.e., distance to all nodes). In link-state, each node talks to all other nodes, but it tells them only what it knows for sure (i.e., only the state of its directly connected links)</p><h3 id="CheckSum-for-IP-packet-header"><a href="#CheckSum-for-IP-packet-header" class="headerlink" title="CheckSum for IP packet header"></a>CheckSum for IP packet header</h3><p>Consider the entire header as a sequence of 16-bit word and do he addition, thus need to use the short type, which is 16 bits/2 bytes. Should use 1’s comlementary addition, the carry in bits should be added back to the right most bit. The principle is that you compare the original checksum contained in the packet and calculated again when you transmit this packet and compare their value.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;IP defines a service model to solve heterogenity, an important part is the global addre
      
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Computer-Network-week4.md</title>
    <link href="http://yoursite.com/2018/02/15/Computer-Network-week4.html"/>
    <id>http://yoursite.com/2018/02/15/Computer-Network-week4.html</id>
    <published>2018-02-16T03:54:37.000Z</published>
    <updated>2018-02-17T15:22:48.040Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Bridges are <strong>link-level nodes</strong> (they forward frames from one link to another to implement an extended LAN), switches are <strong>network-level nodes</strong> (they forward packets from one link to another to implement a packet-switched network), and routers are <strong>internet-level nodes</strong>(they forward datagrams from one network to another to implement an internet). Switch transmit later-2 packets(Ethernet);Router transmit <strong>IP datagrams.</strong></p><h2 id="Internetworking-IP"><a href="#Internetworking-IP" class="headerlink" title="Internetworking(IP)"></a>Internetworking(IP)</h2><p>IP network which can handle scale and heterogenity, LAN with bridges can only scale to small network.<br><a id="more"></a><br>An internetwork is a collection of networks. The <strong>router</strong> connects small networks together.<br>Addressing scheme, provides the way to identify all hosts in the IP. Datagram model of delivery, best effort service model to deliver datagrams.<br>Best effort means that the network does nothing if sth. fails, called an unreliable service.<br>设计思想，让router尽可能简单，不能在connection based network上进行connectionless的服务。<strong>The ability of running IP over anything is cited as its most important characteristics</strong><br>Fail type:out of order, missing, more than once. The upper layer application should notice these errors.<br>Packets format:TOS(type of service),determine whether or not packets be placed in special queue.Thus, the maximum size of an IP datagram is 65,535 bytes. Fragmentation &amp; reassembly is used for not supporting physical layer.<br>TTL: Set it too high and packets could circulate rather a lot before getting dropped. Measured in hopped way.<br>Protocal:upper applications at which this IP layer should be sent.(TCP/UDP).<br>Taking it as 16-bit words and add together using 1-coplementary and take 1 complementary.<br>Source addr determines destination willing to receive or reject. Destination addr allow routing in each hop.<br>为了便于在目标端重组，ident需要有相同的值。IP doesn’t try to recover from failed fragments, if can’t reassembly will drop all. Fragment usually happens when it receives a datagram that <strong>the router</strong> wants to forward a network which has smaller MTU than the datagrams. 尽力避免分段，失败了可能导致GC.<br>To identify the host, unique global address.</p><h2 id="Global-uniquness"><a href="#Global-uniquness" class="headerlink" title="Global uniquness"></a>Global uniquness</h2><p>Ethernet addr is flat, IP addr is hierarchical, by which we mean that they are made up of several parts that correspond to some sort of hierarchy in the internetwork. IP:network number + host number identifies this host in the network.<strong>IP address belong to the interface of 1 router, which then connects to all other network.</strong><br>Class IP address:not flexible enough.<br>Don’t confuse Internet domain names with IP address:domain name such as seu.edu.cn,IP is set of number sequence.</p><h2 id="Datagram-forwarding-in-IP"><a href="#Datagram-forwarding-in-IP" class="headerlink" title="Datagram forwarding in IP"></a>Datagram forwarding in IP</h2><p>forwarding is the process of taking a packet from an input and sending it out on the appropriate output, while routing is the process of building up the tables that allow the correct output for a packet to be determined.<strong>必须有router才能构成IP网络</strong>.<br>Process:whenever recieves a packets, compare <strong>the network part of this packet and the network part of itself interface.</strong> If the same, it means the destination lies in the same physical network as the interface, Thus can be directly delivered.<br>第一种情形，一个网络里面，直接转发。<br>第二种情形，发送到一个router，作为next hop再发送到下一个router consulting their <strong>forwarding table</strong>. &lt; Network number,next router &gt; in each entry.<br>为什么classless address具有scalibility？<br>class assignment:lack <strong>assignment efficiency</strong>.现在forwarding table only needs to contains <strong>several networking number</strong> rather than all of the nodes in the network. <strong>hierachical aggregation</strong> 减少nodes中存储的信息。信息过多影响检索性能。<br>Configuring each node on network with the same netmask, hosts may be on different physical network but share a single network number.每个主机配置一个IP address&amp;&amp;subnetmask. Bit wise AND to see if it can <strong>directly sends over the subnet.</strong>otherwise, needs to be sent to a router to forward to the destination.</p><h2 id="Router-forwarding-process"><a href="#Router-forwarding-process" class="headerlink" title="Router forwarding process"></a>Router forwarding process</h2><p>转发表的Entry转变成&lt; subnetnumber,subnetmask,nexthop &gt;, And the packets’s detination address with subnetmask and if equals the sunetnumber, this is the right entry to use, it forwards to the next hop router indicated, until match make the transmission.</p><h2 id="Classless-addressing"><a href="#Classless-addressing" class="headerlink" title="Classless addressing"></a>Classless addressing</h2><p>CIDR==supernetting.</p><h2 id="Longest-prefixing"><a href="#Longest-prefixing" class="headerlink" title="Longest prefixing"></a>Longest prefixing</h2><p>Use some high efficiency algorithms.</p><h2 id="ARP-只有部分主机会学习源主机的映射"><a href="#ARP-只有部分主机会学习源主机的映射" class="headerlink" title="ARP(只有部分主机会学习源主机的映射)"></a>ARP(只有部分主机会学习源主机的映射)</h2><p>Needs to excapsulate the IP datagram in the Ethernet packets with physical address thus can transmit in link-level.<br>Each host has the mapping table for map IP address to MAC Address, it should be able to learn by itself using ARP.<strong>存储在ARP cache</strong>里面，有timeout schema.<br>原理：网络支持广播。找不到就广播ARP请求，match的项目记录到cache里面。<strong>target的host会将请求者的IP-&gt;MAC映射保存到cache里面，含有请求者映射的host会更新表项中的entry时间，其他host则不会记录这个映射。</strong></p><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>Only requirement for MAC address is uniquness. IP address needs to be configurable, its number can be variable.<br>DHCP relies on a DHCP server that is responsible for providing configuration information to other hosts.<br>Allocate a range of IP address to the network, and store in the configuration info in the DHCP server, each host retrieve info using the table.<br>It is not really desirable to require one DHCP server on every network, because this still creates a potentially large number of servers that need to be correctly and consistently configured. Usually there is a <strong>relay agent</strong>.It only contains the address of the DHCP server. When a relay agent receives a DHCPDISCOVER message, it unicasts it to the DHCP server and awaits the response, which it will then send back to the requesting client.<br>process:boot hosts-&gt;DHCP discover send to broadcast address-&gt;relay agent <strong>unicast</strong> to DHCP server-&gt;DHCP response-&gt;host update lease .Address will expire after lease time. Thus need to renew lease.<br>Core:UDP packets which runs on IP.</p><h2 id="ICMP-Internet-control-message-protocal"><a href="#ICMP-Internet-control-message-protocal" class="headerlink" title="ICMP(Internet control message protocal)"></a>ICMP(Internet control message protocal)</h2><p>For example, ICMP defines error messages indicating that the destination host is unreachable (perhaps due to a link failure), that the reassembly process failed, that the TTL had reached 0, that the IP header checksum failed, and so on.<br>可以返回报告给source host.<br><strong>ICMP redirect</strong> tells the source host there is some better route path.<strong>ping,traceroute</strong> also based on ICMP.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bridges are &lt;strong&gt;link-level nodes&lt;/strong&gt; (they forward frames from one link to another to implement an extended LAN), switches are &lt;strong&gt;network-level nodes&lt;/strong&gt; (they forward packets from one link to another to implement a packet-switched network), and routers are &lt;strong&gt;internet-level nodes&lt;/strong&gt;(they forward datagrams from one network to another to implement an internet). Switch transmit later-2 packets(Ethernet);Router transmit &lt;strong&gt;IP datagrams.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Internetworking-IP&quot;&gt;&lt;a href=&quot;#Internetworking-IP&quot; class=&quot;headerlink&quot; title=&quot;Internetworking(IP)&quot;&gt;&lt;/a&gt;Internetworking(IP)&lt;/h2&gt;&lt;p&gt;IP network which can handle scale and heterogenity, LAN with bridges can only scale to small network.&lt;br&gt;
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Java small details</title>
    <link href="http://yoursite.com/2018/02/15/Java-small-details.html"/>
    <id>http://yoursite.com/2018/02/15/Java-small-details.html</id>
    <published>2018-02-15T22:50:31.000Z</published>
    <updated>2018-02-16T15:47:29.654Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="When-update-an-entry-of-HashMap"><a href="#When-update-an-entry-of-HashMap" class="headerlink" title="When update an entry of HashMap"></a>When update an entry of HashMap</h2><p>Imagine there is an HashMap with entry properties, mapped from String to Object, this value only contains a refrence to the value field. Thus you can directly call the <strong>set methods</strong> of the object, and it will get reflected in the HashMap. The situation also applies to arrayList as value of this entry.<br><a id="more"></a></p><h2 id="3-approaches-to-execute-a-function-after-certain-timeinterval"><a href="#3-approaches-to-execute-a-function-after-certain-timeinterval" class="headerlink" title="3 approaches to execute a function after certain timeinterval"></a>3 approaches to execute a function after certain timeinterval</h2><h3 id="using-simple-thread"><a href="#using-simple-thread" class="headerlink" title="using simple thread"></a>using simple thread</h3><p>This is very simple, which creates the simple thread puts it run in forever with use of while loop and makes use of sleep method to put the interval between running.<br>&lt;% start codeblock %&gt;<br>public class Task1 {<br>public static void main(String[] args) {<br>    // run in a second<br>    final long timeInterval = 1000;<br>    Runnable runnable = new Runnable() {</p><pre><code>public void run() {    while (true) {    // ------- code for task to run    System.out.println(&quot;Hello !!&quot;);    // ------- ends here    try {    Thread.sleep(timeInterval);    } catch (InterruptedException e) {        e.printStackTrace();    }    }    }};Thread thread = new Thread(runnable);thread.start();</code></pre><p>  }<br>}<br>&lt;% endcodeblock %&gt;</p><h3 id="using-the-Timer-and-TimerTask"><a href="#using-the-Timer-and-TimerTask" class="headerlink" title="using the Timer and TimerTask"></a>using the Timer and TimerTask</h3><p>This has much more benefits than previous they are as follows</p><ul><li>control over when start and cancel task</li><li>first execution can be delayed if wanted, provides useful<br>&lt;% start codeblock %&gt;<br>import java.util.Timer;<br>import java.util.TimerTask;</li></ul><p>public class Task2 {</p><p>  public static void main(String[] args) {<br>    TimerTask task = new TimerTask() {<br>      @Override<br>      public void run() {<br>        // task to run goes here<br>        System.out.println(“Hello !!!”);<br>      }<br>    };</p><pre><code>Timer timer = new Timer();long delay = 0;long intevalPeriod = 1 * 1000; // schedules the task to be run in an interval timer.scheduleAtFixedRate(task, delay,                            intevalPeriod);</code></pre><p>  } // end of main<br>}<br>&lt;% endcodeblock %&gt;</p><h3 id="using-ScheduledExecutorService"><a href="#using-ScheduledExecutorService" class="headerlink" title="using ScheduledExecutorService"></a>using ScheduledExecutorService</h3><p>This is introduced in java.util.concurrent from Java SE 5 as Concurrency utilities. This is preferred way to achieve the goal.<br>It provides following benefits as compared to previous solutions</p><ul><li>pool of threads is used to execute as compared TImer’s single thread </li><li>Provides the flexibility for delaying first execution</li><li>Provides nice conventions for providing the time intervals<br>&lt;% start codeblock %&gt;<br>import java.util.concurrent.Executors;<br>import java.util.concurrent.ScheduledExecutorService;<br>import java.util.concurrent.TimeUnit;</li></ul><p>public class Task3 {</p><p>  public static void main(String[] args) {</p><pre><code>Runnable runnable = new Runnable() {  public void run() {    // task to run goes here    System.out.println(&quot;Hello !!&quot;);  }};ScheduledExecutorService service = Executors                .newSingleThreadScheduledExecutor();service.scheduleAtFixedRate(runnable, 0, 1, TimeUnit.SECONDS);</code></pre><p>  }<br>}<br>&lt;% endcodeblock %&gt;</p><h2 id="Corner-trace-of-Java-SE"><a href="#Corner-trace-of-Java-SE" class="headerlink" title="Corner trace of Java SE"></a>Corner trace of Java SE</h2><p>Can use Integer.equals() to compare whether 2 Integer has equal values, but the first parameter where the Integer is called on shouldn’t be null. m1.equals(null) can be called to compare.<br>Using equals to compare 2 objects, if the equals methods has been overriden, these overriden methods will be called, otherwise just use == to compare whether 2 object reference to the same object.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;When-update-an-entry-of-HashMap&quot;&gt;&lt;a href=&quot;#When-update-an-entry-of-HashMap&quot; class=&quot;headerlink&quot; title=&quot;When update an entry of HashMap&quot;&gt;&lt;/a&gt;When update an entry of HashMap&lt;/h2&gt;&lt;p&gt;Imagine there is an HashMap with entry properties, mapped from String to Object, this value only contains a refrence to the value field. Thus you can directly call the &lt;strong&gt;set methods&lt;/strong&gt; of the object, and it will get reflected in the HashMap. The situation also applies to arrayList as value of this entry.&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Computer-Network-week3</title>
    <link href="http://yoursite.com/2018/02/14/Computer-Network-week3.html"/>
    <id>http://yoursite.com/2018/02/14/Computer-Network-week3.html</id>
    <published>2018-02-15T02:58:45.000Z</published>
    <updated>2018-02-16T15:46:01.912Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Data-link-layer-amp-amp-Transport-layer"><a href="#Data-link-layer-amp-amp-Transport-layer" class="headerlink" title="Data link layer &amp;&amp; Transport layer"></a>Data link layer &amp;&amp; Transport layer</h2><p>Data link layer: consists of Logic link layer and medium access control. <strong>dataframes transmission*,encapsulates network layer data into frmaes. responsible for </strong>local delivery of frames<strong> between devices on the same LAN.  example protocals:Ethernet for local area network(multinodes);PPP, HDLC.<br><a id="more"></a><br>Transport layer:</strong>TCP/UDP packets<strong>.provides host to host transmission for applications, provides connection oriented and reliable, flow control, multiplexing.<br>The transport layer is responsible for </strong>delivering data to the appropriate application process on the host computers.**<br>Capacity: max rate you can sent in unit time.<br>Throughput: data transferred/sent in unit time.<br>Circuit switching&amp;Packet switching:circuit needs to setup connection, there is overhead and reliable connection based. Packet switching no overhead, with unreliable, connectionless transmission.</p><h2 id="Switch-amp-amp-Bridges"><a href="#Switch-amp-amp-Bridges" class="headerlink" title="Switch &amp;&amp; Bridges"></a>Switch &amp;&amp; Bridges</h2><p>Switch transfers single input multi/single output devices, enables large size network. Adds star topology to network.<br>Property of star topology:1.can build large wtwork by interconnecting several switches together.<br>2.adding new hosts to network won’t influence performance.s<br>Switch network is more <strong>scalable</strong>. While it’s impossible to send packets simutaneously at the same time on the same medium.<br>Switching/forwarding is main functionality of <strong>network layer</strong>.<br>Identify ports by numbering its port or name of nodes which connects to the port.<br>This switching &amp; forwarding canbe connection or connectionless. </p><h2 id="Datagram"><a href="#Datagram" class="headerlink" title="Datagram"></a>Datagram</h2><p>Using forwarding table to deal with a datagram, which has enough information to decide where to go.<br>A host can send a packet anywhere at any time, since any packet that turns up at a switch can be immediately forwarded (assuming a correctly populated forwarding table). For this reason, datagram networks are often called connectionless; this contrasts with the connection-oriented networks described below, in which some connection state needs to be established before the first data packet is sent.<br>The host doesn’t know anything about dest when it sends out datagram.<br>Each packets is forwarded independently, and they can follow different path when sent out.<br>If there is any alternatives to route, failures can be accepted.</p><h2 id="Virtual-circuit-switch"><a href="#Virtual-circuit-switch" class="headerlink" title="Virtual circuit switch"></a>Virtual circuit switch</h2><p>Connection based.<br>1.connection setup<br>2.data transfer<br>1 entry in the VC table contains:1.VCI,2.incoming interface3.outcoing interface4.potential interface<br>VPN/ATM based on virtual circuits.</p><h2 id="Bridges-amp-amp-Switches"><a href="#Bridges-amp-amp-Switches" class="headerlink" title="Bridges &amp;&amp; Switches"></a>Bridges &amp;&amp; Switches</h2><p>LAN switches==bridges for region network.<br>Ethernet bridges can scale the throughput of network by n.</p><h2 id="Issue-with-switches-and-bridges"><a href="#Issue-with-switches-and-bridges" class="headerlink" title="Issue with switches and bridges"></a>Issue with switches and bridges</h2><p>Issues with bridges:<strong>scale and heterogenenity</strong>;broadcast don’t scale, spanning tree algorithms will expand linearly.<br>解决方案:VLAN.single LAN partitioned into several seemingly separated LAN.If both segments have same identifier can packets travel from one to another. For heterogenenity, it can only supports network with same address format, with same address header.<br>优势:transparency.</p><h2 id="Learning-bridges"><a href="#Learning-bridges" class="headerlink" title="Learning bridges"></a>Learning bridges</h2><p>Each time bridges will inspect the source address of packets it receive. Has timeout mechanism with each entry in the table. If a frame received with destination address not known, will send to all of other ports.</p><h2 id="Spanning-tree-algorithms"><a href="#Spanning-tree-algorithms" class="headerlink" title="Spanning tree algorithms"></a>Spanning tree algorithms</h2><p>Reason:maybe due to not single administrator, or redundancy on purpose, in case of failure.<br>Construct a spanning tree in order to avoid cycle graph.<br>The hard part is how all of the bridges coordinate their decisions to arrive at a single view of the spanning tree. After all, one topology is typically able to be covered by <strong>multiple spanning trees.</strong><br>Dynamic algorithms should some bridge failed will always reconstruct a new spanning tree.<br>Process:<br>1.Selects the bridge with the smallest ID as the bridge root. root always transmit through all its port.<br>2.each bridge computes their shortest path to the root bridge. Record which port is on the path.<br>3.Finally, all the bridges connected to a given LAN elect a single designated bridge that will be responsible for forwarding frames toward the root bridge. Each LAN’s designated bridge is the one that is closest to the root. 选取一个网桥作为LAN的代表连接到Root节点。(同时有两个网桥连接到同一个LAN才会进行网桥选取，其他时候直接选择连接LAN的路径)<br>Configuration message:ID of current bridge, distance to root bridge, ID of root bridge.开始每个网桥都认为自己是root，直到收到更好的配置信息，就不再产生配置信息，持续等待其他配置并进行转发，最终稳定态只有一个根节点在持续产生配置信息.</p><h2 id="Broadcast-amp-amp-Multicast"><a href="#Broadcast-amp-amp-Multicast" class="headerlink" title="Broadcast &amp;&amp; Multicast"></a>Broadcast &amp;&amp; Multicast</h2><p>Bridges should also be able to support broadcast+multicast. Broadcast is simple, only need to transmit frames on all ports other than the port reveiving this port.<br>Multicast can be implemented in the same way, except the host should decides whether it will recieve the packets.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Data-link-layer-amp-amp-Transport-layer&quot;&gt;&lt;a href=&quot;#Data-link-layer-amp-amp-Transport-layer&quot; class=&quot;headerlink&quot; title=&quot;Data link layer &amp;amp;&amp;amp; Transport layer&quot;&gt;&lt;/a&gt;Data link layer &amp;amp;&amp;amp; Transport layer&lt;/h2&gt;&lt;p&gt;Data link layer: consists of Logic link layer and medium access control. &lt;strong&gt;dataframes transmission*,encapsulates network layer data into frmaes. responsible for &lt;/strong&gt;local delivery of frames&lt;strong&gt; between devices on the same LAN.  example protocals:Ethernet for local area network(multinodes);PPP, HDLC.&lt;br&gt;
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Database design theory</title>
    <link href="http://yoursite.com/2018/02/14/Database-design-theory.html"/>
    <id>http://yoursite.com/2018/02/14/Database-design-theory.html</id>
    <published>2018-02-14T21:44:23.000Z</published>
    <updated>2018-02-16T15:46:49.243Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Functional-Dependencies"><a href="#Functional-Dependencies" class="headerlink" title="Functional Dependencies"></a>Functional Dependencies</h2><a id="more"></a><p>A-&gt;C,D. A can uniquly determined a C, C,D can be independently determined <strong>by</strong> A. if there are single A mapping to multiple C, it doesn’t hold.<br>1.reflexity:A,B,C-&gt;C, A,B,C-&gt;A,B<br>2.aumentation:A-&gt;B,  A,Z-&gt;B,Z<br>3.transivity:A-&gt;B,B-&gt;C,A-&gt;C</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Functional-Dependencies&quot;&gt;&lt;a href=&quot;#Functional-Dependencies&quot; class=&quot;headerlink&quot; title=&quot;Functional Dependencies&quot;&gt;&lt;/a&gt;Functional Dependencies&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>redis documentation summary</title>
    <link href="http://yoursite.com/2018/02/14/redis-documentation-summary.html"/>
    <id>http://yoursite.com/2018/02/14/redis-documentation-summary.html</id>
    <published>2018-02-14T15:26:32.000Z</published>
    <updated>2018-02-15T02:11:10.874Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Redis-architecture"><a href="#Redis-architecture" class="headerlink" title="Redis architecture"></a>Redis architecture</h2><p>Implemented in C, the performance mainly lies in how OS schedules each process and the cost spent in network communication and sockets reading/writing system call.<br><a id="more"></a></p><h2 id="Normal-command"><a href="#Normal-command" class="headerlink" title="Normal command"></a>Normal command</h2><p>1.bgsave:save db in background,The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits.<br>2.client kill [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no].<br>3.client list:list all client connection<br>4.client pause:stop processing commands from client for some time.<br>5.client getname:get name of current client connection/client setname:set name of current connection<br>6.cluster nodes:集群模式nodes配置、<br>7.config get params:get configuration of certain configuration.<br>8.get key:get value of key/append key value:键值插入value<br>9.debug object [key]:get debug information about a key<br>10.exists [key] determine if it exists<br>11.<strong>exec</strong>:execute all commands queued in  a transaction and restores the connection state to normal.<br>12.<strong>MULTI</strong>:Marks the start of a transaction block. Subsequent commands will be queued for atomic execution using EXEC.<br>13.<strong>save</strong> synchnrously save all keys to index.<br>14.TTL [key]:get the time for a key to live.</p><h2 id="Piplining"><a href="#Piplining" class="headerlink" title="Piplining"></a>Piplining</h2><p>Redis is a TCP server using the <strong>client-server model and what is called a Request/Response protocol.</strong><br>This means that usually a request is accomplished with the following steps:<br>The client sends a query to the server, and reads from the socket, usually in a blocking way, for the server response.<br>The server processes the command and sends the response back to the client.<br>the server &amp; client may not live in the same mahcine.(many hop)<br>Whatever the network latency is, there is a time for the packets to travel from the client to the server, and back from the server to the client to carry the reply.<br>How to reduce RTT in the network, thus improve the throughput in DB?<br>This way it is possible to send multiple commands to the server without waiting for the replies at all, and <strong>finally read the replies in a single step.</strong>server is forced to queue the replies using memory.<br>pipling save time in:1.<strong>socket I/O</strong>,read/write syscall with context switch2.RTT time is reduced with multiple commands batched together.<br>具体方法是用特定的ClientAPI实现pipling 请求batch.</p><h2 id="Pub-sub-mechanism"><a href="#Pub-sub-mechanism" class="headerlink" title="Pub/sub mechanism"></a>Pub/sub mechanism</h2><p>SUBSCRIBE, UNSUBSCRIBE and PUBLISH implement the Publish/Subscribe messaging paradigm where (citing Wikipedia) senders (publishers) are not programmed to send their messages to specific receivers (subscribers). Rather, published messages are characterized into channels, without knowledge of what (if any) subscribers there may be. Subscribers express interest in one or more channels, and only receive messages that are of interest, without knowledge of what (if any) publishers there are. This decoupling of publishers and subscribers can allow for greater scalability and a more dynamic network topology.<br>消息分类，不发送给特定人群。<br><code>subscribe foo bar</code>listen to certain channel.<br><code>publish channel message</code>publish message to certain channel</p><h2 id="Expires-mechanism"><a href="#Expires-mechanism" class="headerlink" title="Expires mechanism"></a>Expires mechanism</h2><p>it’s the core of which it can be used as cache, set a key with some time such that it will get expired.<strong>volatile</strong><br>using persist [key] to clear the timeout.</p><h2 id="Using-Redis-as-an-LRU-cache"><a href="#Using-Redis-as-an-LRU-cache" class="headerlink" title="Using Redis as an LRU cache"></a>Using Redis as an LRU cache</h2><p>When Redis is used as a cache, often it is handy to let it automatically evict old data as you add new one. This behavior is very well known in the community of developers, since it is the default behavior of the popular <strong>memcached system.</strong><br>in redis.conf:configure with <code>maxmemory 100mb</code>.<br><code>maxmemory-policy</code>:<code>volatile-lru</code>: evict keys by trying to remove the less recently used (LRU) keys first, but only among keys that have an expire set, in order to make space for the new data added.</p><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><p><code>multi</code> with multi operation,<code>exec</code> will start execution of transaction. <code>discard</code>will flush the transaction queue and exit. Atomicity, executed/or not.<br>No roll back for redis, when failed may still get some operation executed.<strong>Redis is internally simplified and faster because it does not need the ability to roll back.</strong>主要目的就是快！！</p><h2 id="Implement-self-modules"><a href="#Implement-self-modules" class="headerlink" title="Implement self modules"></a>Implement self modules</h2><p>in C, and load it later can extend the command supported. Module load ….so. //in conf file:<strong>loadmodule /path/file.so</strong>.</p><h2 id="Disgtributed-locks-with"><a href="#Disgtributed-locks-with" class="headerlink" title="Disgtributed locks with"></a>Disgtributed locks with</h2><p>already have Java implementation</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis-architecture&quot;&gt;&lt;a href=&quot;#Redis-architecture&quot; class=&quot;headerlink&quot; title=&quot;Redis architecture&quot;&gt;&lt;/a&gt;Redis architecture&lt;/h2&gt;&lt;p&gt;Implemented in C, the performance mainly lies in how OS schedules each process and the cost spent in network communication and sockets reading/writing system call.&lt;br&gt;
    
    </summary>
    
    
      <category term="Java ee" scheme="http://yoursite.com/tags/Java-ee/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-tree-prictice</title>
    <link href="http://yoursite.com/2018/02/10/leetcode-tree-prictice.html"/>
    <id>http://yoursite.com/2018/02/10/leetcode-tree-prictice.html</id>
    <published>2018-02-10T18:16:44.000Z</published>
    <updated>2018-02-16T23:35:23.996Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="742-Nearest-to-leaf-node"><a href="#742-Nearest-to-leaf-node" class="headerlink" title="742.Nearest to leaf node"></a>742.Nearest to leaf node</h2><p>Find the treenode whose value == k first, then can use <strong>BFS</strong> to find the nearest leaf node to this target node.(Clever mind, once find target node, guaranteed to be nearest node).<br><a id="more"></a><br>TreeNode left, right’s writing will ensure that as if the target node is not dfind, it will continually add the current node and parent node to the hashMap, only ignore those node where their depth are deeper than the current node.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findClosestLeaf</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;TreeNode,TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        TreeNode target = findDFS(parent, k, root);</span><br><span class="line">        Queue&lt;TreeNode&gt; visit = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        visit.offer(target);</span><br><span class="line">        Set&lt;TreeNode&gt;stat = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        stat.add(target);</span><br><span class="line">        <span class="keyword">while</span>(visit.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode cur = visit.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left==<span class="keyword">null</span>&amp;&amp;cur.right==<span class="keyword">null</span>) <span class="keyword">return</span> cur.val;</span><br><span class="line">            <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>&amp;&amp; stat.add(cur.left)) &#123;</span><br><span class="line">                visit.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span> &amp;&amp; stat.add(cur.right)) &#123;</span><br><span class="line">                visit.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(parent.containsKey(cur) &amp;&amp; stat.add(parent.get(cur))) &#123;</span><br><span class="line">                visit.offer(parent.get(cur));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">findDFS</span><span class="params">(Map&lt;TreeNode,TreeNode&gt;parent, <span class="keyword">int</span> k, TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val == k) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.put(root.left,root);</span><br><span class="line">            TreeNode left = findDFS(parent,k,root.left);</span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent.put(root.right,root);</span><br><span class="line">            TreeNode right = findDFS(parent,k,root.right);</span><br><span class="line">            <span class="keyword">if</span>(right!=<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="250-Count-Univalue-Subtrees"><a href="#250-Count-Univalue-Subtrees" class="headerlink" title="250. Count Univalue Subtrees"></a>250. Count Univalue Subtrees</h2><p>Subtree should include all of its left&amp;&amp;right treenodes. can’t be single branch of one node… Notice that this type of problem all use post traversal to solve…<br>compare each leaves with their parent nodes and follow along the path to get upper side.<strong>Only when both left&amp;&amp;right subtree all counted as univalue can it be counted as univalue</strong><br>Why use int[] as params?<br>Here int[] works like a wrap. When you pass (int[])arr to a method, it creates a new reference point to the same object as arr and pass the <strong>new reference to the method</strong>. Hence when you change for example arr[0] in the method call, since both of the references point to the same object, it will reflect on arr in the parent call;<br>int is a primitive type, you pass a int variable to a method it simply makes a copy of the variable and pass it to the method.<br>Thus, use a array can be equivlant to use a global variable.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;742-Nearest-to-leaf-node&quot;&gt;&lt;a href=&quot;#742-Nearest-to-leaf-node&quot; class=&quot;headerlink&quot; title=&quot;742.Nearest to leaf node&quot;&gt;&lt;/a&gt;742.Nearest to leaf node&lt;/h2&gt;&lt;p&gt;Find the treenode whose value == k first, then can use &lt;strong&gt;BFS&lt;/strong&gt; to find the nearest leaf node to this target node.(Clever mind, once find target node, guaranteed to be nearest node).&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>IDEA cant resolve properties solution</title>
    <link href="http://yoursite.com/2018/02/09/IDEA-cant-resolve-properties-solution.html"/>
    <id>http://yoursite.com/2018/02/09/IDEA-cant-resolve-properties-solution.html</id>
    <published>2018-02-09T16:07:24.000Z</published>
    <updated>2018-02-16T15:47:11.630Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Can’t-resolve-symbol’s-solution"><a href="#Can’t-resolve-symbol’s-solution" class="headerlink" title="Can’t resolve symbol’s solution"></a>Can’t resolve symbol’s solution</h2><p>Need to check each header of the .xml whether it has some schemaLocation left out. Besides, delete the .iml and reimport the project file.<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Can’t-resolve-symbol’s-solution&quot;&gt;&lt;a href=&quot;#Can’t-resolve-symbol’s-solution&quot; class=&quot;headerlink&quot; title=&quot;Can’t resolve symbol’s solution&quot;&gt;&lt;/a&gt;Can’t resolve symbol’s solution&lt;/h2&gt;&lt;p&gt;Need to check each header of the .xml whether it has some schemaLocation left out. Besides, delete the .iml and reimport the project file.&lt;br&gt;
    
    </summary>
    
    
      <category term="Java ee" scheme="http://yoursite.com/tags/Java-ee/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network Week2</title>
    <link href="http://yoursite.com/2018/02/08/Computer-Network-week2.html"/>
    <id>http://yoursite.com/2018/02/08/Computer-Network-week2.html</id>
    <published>2018-02-09T02:42:07.000Z</published>
    <updated>2018-03-02T15:06:28.978Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Forwarding-amp-amp-Routing"><a href="#Forwarding-amp-amp-Routing" class="headerlink" title="Forwarding &amp;&amp; Routing"></a>Forwarding &amp;&amp; Routing</h2><p>Forwarding consists of taking a packet, looking at its destination<br>address, consulting a table, and <strong>sending the packet in a direction determined by that table.</strong>forwarding is a relatively simple and well-defined process performed locally at a node, whereas <strong>routing depends on complex distributed algorithms that have continued to evolve throughout the history of networking.</strong><br>routing table usually just contains mapping from network prefixes to next hops.<br><a id="more"></a><br>the forwarding table needs to be structured to optimize the process of looking up an address when forwarding a packet, while the routing table needs to be optimized for the purpose of calculating changes in topology.<br>Theforwarding table is used when a packet is being forwarded and so must contain enough information to accomplish the forwarding function. This means that a row in the forwarding table contains the mapping from a network prefix to an outgoing interface and some MAC information, such as the Ethernet address of the next hop. The routing table, on the other hand, is the table that is built up by the routing algorithms as a precursor to building the forwarding table. It generally contains mappings from network prefixes to next hops. It may also contain information about how this information was learned, so that the router will be able to decide when it should discard some information.</p><h2 id="Routing-algorithms"><a href="#Routing-algorithms" class="headerlink" title="Routing algorithms"></a>Routing algorithms</h2><p>IGPs(Intra domain Protocals/Interior gateway protocal) can’t scale very well for large size network.<br>Routing domain: an internetwork where all router are under single administrative control.<br>Basic:shortest path problems. calculating all shortest paths and store them into each node table.<br>Usually use distributed algorithms to run on all nodes.<br>1.distance vector:RIP(Bellman-ford),<br>The next step in distance-vector routing is that every node sends a message to its directly connected neighbors containing its personal list of distances. The process of getting all nodes getting consistent information about routes is called convergence. Each nodes only know about its own table.<br>Whenever routing table changed or some link get failed, will notify its neighbors and updated the table. node continually detects whether a link is working by continually sending control packets and receiving acknowledgements.<br>2.link state:</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Forwarding-amp-amp-Routing&quot;&gt;&lt;a href=&quot;#Forwarding-amp-amp-Routing&quot; class=&quot;headerlink&quot; title=&quot;Forwarding &amp;amp;&amp;amp; Routing&quot;&gt;&lt;/a&gt;Forwarding &amp;amp;&amp;amp; Routing&lt;/h2&gt;&lt;p&gt;Forwarding consists of taking a packet, looking at its destination&lt;br&gt;address, consulting a table, and &lt;strong&gt;sending the packet in a direction determined by that table.&lt;/strong&gt;forwarding is a relatively simple and well-defined process performed locally at a node, whereas &lt;strong&gt;routing depends on complex distributed algorithms that have continued to evolve throughout the history of networking.&lt;/strong&gt;&lt;br&gt;routing table usually just contains mapping from network prefixes to next hops.&lt;br&gt;
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Mininet virtual network</title>
    <link href="http://yoursite.com/2018/02/05/Mininet-virtual-network.html"/>
    <id>http://yoursite.com/2018/02/05/Mininet-virtual-network.html</id>
    <published>2018-02-06T00:40:34.000Z</published>
    <updated>2018-02-07T15:48:56.398Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Basic-usage"><a href="#Basic-usage" class="headerlink" title="Basic usage"></a>Basic usage</h2><p>$Linux mode<br><a id="more"></a><br>mininet&gt;:mininet command<br><code>sudo mn -h</code>:show all help commands<br>start a minimal topology:<code>sudo mn</code>. create 1 openflow switch with 2 hosts.<br>nodes:show all nodes;<br>net:show all links;<br>dump:dump all information about all nodes;<br>nodename ifconfig -a:在指定节点上运行指定指令;<br>s1 arp/route:显示网关和硬件地址;<br>s1/h1 ps -a:显示当前进程的所有进程<br>s1 ping -c 1 h2:检测连接情况,-c为发送的全部数据包数目<br>ping的第一次要ARP,广播泛红所有请求到网络里面是所有的主机,找到目标主机应答相应的MAC address返回到controller再应答主机。</p><h2 id="Host指令"><a href="#Host指令" class="headerlink" title="Host指令"></a>Host指令</h2><p>模式下支持所有Bash指令。<br>Run a simple web server and client：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mininet&gt; h1 python -m SimpleHTTPServer 80 &amp;//创建一个新进程</span><br><span class="line">mininet&gt; h2 wget -O - h1</span><br><span class="line">...</span><br><span class="line">mininet&gt; h1 kill %python</span><br></pre></td></tr></table></figure><br><code>sudo mn -c</code>clean up the host;</p><h2 id="Analysis-of-network"><a href="#Analysis-of-network" class="headerlink" title="Analysis of network"></a>Analysis of network</h2><p>self contained-regression test:<code>sudo mn --test pingpair</code>:run all pairs ping test and return the total time and tore down situation.<br><code>sudo mn --test iperf</code>:test bandwidth between each host pair.<br>regression test: sudo mn –topo single,3:1 switch and 3 hosts.<br>sudo mn –topo linear,4<br>Link variations:人为改变链路参数:<code>sudo mn --link tc,bw=10,delay=10ms</code><br>tc:traffic control utility<br>Adjustable Verbosity:调整信息模式，默认是info.<br>sudo mn -v ouput/debug</p><h2 id="Interact-with-mininet-shell"><a href="#Interact-with-mininet-shell" class="headerlink" title="Interact with mininet shell"></a>Interact with mininet shell</h2><p><strong>the round trip time (RTT)</strong><br><code>py locals()</code><br><code>py dir(h1)</code>:methods and file avaliable from a host<br><code>py h1.IP()</code>:evaluate a variable<br>Link up and down:For fault tolerance testing, it can be helpful to bring links up and down.<br><code>link s1 h1 down</code><br><code>link s1 h1 up</code>建立链路<br><strong>When running ping and Iperfer in Mininet, you must use IP addresses, not hostnames.</strong><br>ping:send ICMP echo requests to hosts;-F flow to all hosts,-f flood ping</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Basic-usage&quot;&gt;&lt;a href=&quot;#Basic-usage&quot; class=&quot;headerlink&quot; title=&quot;Basic usage&quot;&gt;&lt;/a&gt;Basic usage&lt;/h2&gt;&lt;p&gt;$Linux mode&lt;br&gt;
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Java IO</title>
    <link href="http://yoursite.com/2018/02/05/Java-IO.html"/>
    <id>http://yoursite.com/2018/02/05/Java-IO.html</id>
    <published>2018-02-06T00:14:09.000Z</published>
    <updated>2018-03-02T15:46:25.863Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="IO-stream-classification"><a href="#IO-stream-classification" class="headerlink" title="IO stream classification"></a>IO stream classification</h2><p>字节流：FileInputstream (继承自InputStream),StringBufferInputStream(从字符串里读取Byte源数据)<br>字符流：Reader(Abstract class,implements <strong>Readable,Closeable</strong>),subclass must implements read(char[],int,int),read into a portion of array.<br>Buffered Reader:Reads text from a <strong>character-input stream</strong>, buffering characters so as to provide for the efficient reading of characters, arrays, and lines.<br>InputStreamReader:bridge from bytestream to character stream.<br>FileReader(File file/filedescriptor/String filename):read(char[],int,int):read characters into a portion of array.<br>For top efficiency, consider wrapping an InputStreamReader within a BufferedReader. For example:<br><code>BufferedReader in= new BufferedReader(new InputStreamReader(System.in);</code><br>字节流：<br>InputStream()方法：<br>read():for read 1 byte, read(byte[])for read some number of bytes into buffer. read(byte[], int start, int len):for read len bytes start from start position.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;IO-stream-classification&quot;&gt;&lt;a href=&quot;#IO-stream-classification&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>python recording for TA grading</title>
    <link href="http://yoursite.com/2018/02/03/python%E7%AE%80%E4%B9%A6.html"/>
    <id>http://yoursite.com/2018/02/03/python简书.html</id>
    <published>2018-02-04T02:19:20.000Z</published>
    <updated>2018-02-13T22:23:06.653Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Sys-amp-os"><a href="#Sys-amp-os" class="headerlink" title="Sys &amp; os"></a>Sys &amp; os</h2><p>sys.argv[] 以list形式存储所有的命令参数，<code>py test.py -c -m</code> 打印所有会从文件名开始打印。”test.py -c -m”。<br><a id="more"></a></p><h2 id="文件IO操作"><a href="#文件IO操作" class="headerlink" title="文件IO操作"></a>文件IO操作</h2><p>程序不能直接对磁盘进行读写操作，使用系统调用接口。每次需要open,read,close,read()可以指定读取数据量大小，否则会一次读取全部可能爆内存。<br>常用语句：with open(program,’rw’) as: filehandle filehadnle.read/write()<br>for l in filehandle. x = input(“”).</p><h2 id="b’’"><a href="#b’’" class="headerlink" title="b’’"></a>b’’</h2><p>Bytes literals are always prefixed with ‘b’ or ‘B’; they produce an instance of the bytes type instead of the str type. They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes.</p><p>str = ‘…’ literals = a sequence of Unicode characters (UTF-16 or UTF-32, depending on how Python was compiled)<br><strong>bytes = b’…’ literals = a sequence of octets (integers between 0 and 255)</strong></p><h2 id="in"><a href="#in" class="headerlink" title="in"></a>in</h2><p>if x in next:depends on what’s next,<br>if next is a string, it <strong>checks for substring</strong>.<br>If it’s a different kind of iterable (list, tuple, dictionary…), then in checks for membership. eg:[1,2,3] in 2,true<br>in a dictionary be seen as be one of the keys.</p><h2 id="sys-path"><a href="#sys-path" class="headerlink" title="sys.path"></a>sys.path</h2><p>sys.path returns a list which contains all modules, including 3rd party module and current path. .append add wanted module path into the path, only take effets when running time.<br>sys.path.append(base):base is the address of referenced module.</p><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>defines a function with hidden name.lambda will return a function object. is a expression not a function,lambda x:x*x.<br>lambda x:load(x);</p><h2 id="Complement-a-Linux-command"><a href="#Complement-a-Linux-command" class="headerlink" title="Complement a Linux command"></a>Complement a Linux command</h2><p>find -name:find file in this folder<br>grep -rHn:parse file contents<br>ls -al:show up <strong>hidden folder</strong> which you may can’t access initially.</p><h2 id="Change-to-Python3-x"><a href="#Change-to-Python3-x" class="headerlink" title="Change to Python3.x"></a>Change to Python3.x</h2><p>print(x) is not required to have parenthsis.<br>Input in python 3.x:always treat as string, x = input(“please input”);x=’10’.<br>With Linux shell,should have <code>#!/usr/bin/python3</code> or <code>#!/usr/bin/env python3</code> to indicate file type and can be executed directly.</p><h2 id="Standard-type"><a href="#Standard-type" class="headerlink" title="Standard type"></a>Standard type</h2><p>multiple assignment:a=b=1////a,b=1,”whw”, use del a to free a variable reference.<br>standard type:<strong>number,string,list,tuple,dictionary</strong>.<br>String supports + as concatenation, [2:5] as substring and <em>2 as repetition.<br>all the items belonging to a list can be of different data type.<br>a[:],a[1:3].<br>The main difference between lists and tuples are − Lists are enclosed in brackets ( [ ] ) and their elements and size can be changed, while tuples are enclosed in parentheses ( ( ) ) and <strong>cannot be updated</strong>. Tuples can be thought of as read-only lists.eg:tinytuple = (123, ‘john’)<br>dictionary:keys can be different type. dict[‘one’] = 1;dict.keys();dict.values();str(),int(),float(),set()(which has unique element and ca use add/remove) used for conversion.<br>boolean operator:and or not.<strong> power. </strong>is*</em> indentifies whether 2 objects are the same. True,False.<br>iterator:use iter to get an iterator of list,a = iter(list),print(next(a)) can get you next value.<br>Number function:pow(x,y),fabs(x),max(),min(),sqrt(),exp(),log(),log10().</p><h2 id="String-methods"><a href="#String-methods" class="headerlink" title="String methods"></a>String methods</h2><p>lstrip,rstrip:remove white space of given string. isdigit(),len(),find(str,begin,(end)) find substring.</p><h2 id="List-methods"><a href="#List-methods" class="headerlink" title="List methods"></a>List methods</h2><p>list.append(obj),list.count(obj) count how many times obj occur.list.reverse().list.sort(function)<br>dict.clear(),dict.get(key,default=none),</p><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>Params passed by referenced type, ie:they are <strong>reflected</strong> outside once changed.变量具有作用域限制。</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>from x import temp, only introduce the temp function and ignore others.<br>Within a module, the module’s name (as a string) is available as the value of the global variable <strong>name</strong>. The code in the module will be executed, just as if you imported it, but only with the <strong>name</strong> set to “<strong>main</strong>“. Like below, the module can be called directly.<br>if <strong>name</strong> == “<strong>main</strong>“:<br>   f = fib(100)<br>   print(f)</p><h2 id="Class-amp-amp-Object"><a href="#Class-amp-amp-Object" class="headerlink" title="Class &amp;&amp; Object"></a>Class &amp;&amp; Object</h2><p>class Employee:<br>    current;    #defined in class equivlant to a class variable, shared               #by all instances<br>    def <strong>init</strong>(self,name,age):<br>other methods all includes a argument called <strong>self</strong>.<br>setattr(obj,name,value);hasattr(obj,name);<br>getattr(obj,name);<br><strong>build in attributes</strong> which can be used . to access anywhere:<br><strong>name</strong>,<strong>dict</strong>:namespace of class,就是整个类的声明。<br>引用计数法清楚变量，索引。<br>An object’s reference count increases when it is assigned a new name or placed in a container (list, tuple, or dictionary). The object’s reference count decreases when it is deleted with del, its reference is reassigned, or its reference goes out of scope. When an object’s reference count reaches zero, Python collects it automatically.<br>Inheritence:class child(parent1,parent2):<br>                xxx<br>Overriding methods:直接命名同名函数。</p><h2 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h2><p>Commmon gateway interface:whenever a file is requested, it’s not returned directly but executed on server side and returns the result back to the browser.</p><h2 id="Database-API"><a href="#Database-API" class="headerlink" title="Database API"></a>Database API</h2><p>import pymysql;<br>connect = pymysql.connect(“localhost”,”root”,”password”,”dbname”);<br>cursor = connect.cursor();<br>cursor.execute(sql);<br>connect.commit();<br>/#results = cursor.fetchall();<br>for row in results:<br>    fname = row[0];<br>    age = row[1];<br>    parent = row[2];<br>try:<br>except:<br>    connect.rollback();</p><h2 id="Multithreading-programming"><a href="#Multithreading-programming" class="headerlink" title="Multithreading programming"></a>Multithreading programming</h2><p>Threading module<br>import threading;</p><h2 id="For-loop-amp-if-else"><a href="#For-loop-amp-if-else" class="headerlink" title="For loop &amp; if else"></a>For loop &amp; if else</h2><p>for cur in paragraph:xxx<br>for index in range(len(nums))<br>if nums[0] == 1://using column to indicate a coding block</p><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><p>2 important data structures:<br>Series:1D array, using index to access value,<br>se.index():默认是0：len-1,se.values()<br>numpy数组操作：bool数组过滤，数乘将保持元素之间的索引<br>使用dict创建Series，键成为index<br>索引index可以就地更改，se.index = [dsad,dsad]<br><strong>Dataframes</strong>:行的索引和列的索引;列索引column是dict的键，row索引是数字<br>直接df[‘state’]索引到的是<strong>整个列</strong>.<br>可以直接给某一列赋值为Series:df[‘state’] = se;<br>data[[‘one’,’two’]]提取两列出来<br>data.ix[2]:索引其中单独的一行<br>data[data&gt;2]选择列过滤行<br>number of rows:len(df.index);number of cols:len(df.columns)</p><p>.loc()label based selection:<br>.loc[index,column]得到具体数值..loc[[‘a’,’b’,’c’],’A’:’C’]选取几个row和column<br>.iloc[[1,3,4],[2]]通过index进行选取，选取个别几列</p><p>series.size()直接获取大小，没有len()方法，df[‘’].str.len()返回选取长度</p><h2 id="Python-class-call-recursive-functions-inside-the-class"><a href="#Python-class-call-recursive-functions-inside-the-class" class="headerlink" title="Python class call recursive functions inside the class"></a>Python class call recursive functions inside the class</h2><p>self.calculate(name,value);//with no self params already</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Sys-amp-os&quot;&gt;&lt;a href=&quot;#Sys-amp-os&quot; class=&quot;headerlink&quot; title=&quot;Sys &amp;amp; os&quot;&gt;&lt;/a&gt;Sys &amp;amp; os&lt;/h2&gt;&lt;p&gt;sys.argv[] 以list形式存储所有的命令参数，&lt;code&gt;py test.py -c -m&lt;/code&gt; 打印所有会从文件名开始打印。”test.py -c -m”。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Database Physical layer concept</title>
    <link href="http://yoursite.com/2018/02/03/Database%20concept.html"/>
    <id>http://yoursite.com/2018/02/03/Database concept.html</id>
    <published>2018-02-03T17:33:53.000Z</published>
    <updated>2018-03-06T15:12:12.541Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Cover materials on Stanford CS145,345,346</p><h2 id="Transaction-Concurrency-amp-Atomicity"><a href="#Transaction-Concurrency-amp-Atomicity" class="headerlink" title="Transaction,Concurrency &amp; Atomicity"></a>Transaction,Concurrency &amp; Atomicity</h2><p>Performace problem:Disk/SSD    access is slow,DBMS hide the latency by    doing more CPU work concurrently.<br><a id="more"></a><br>Transaction:中文翻译成<strong>事务</strong>,<strong>ACID</strong><br>Transactions:A <strong>atomic</strong> sequence of independant read/write. DBMS exsures it is a serial execution of instrucitons. One way to solve is through locking, before r/w requires a locking from DBMS.All concurrency    issues handled by the DBMS.<br>Ensure consistency even if crashed:OS concepts,<strong>write ahead logging,before any action is finalized, a corresponding entry is forced to disk.</strong></p><h2 id="ER-Model"><a href="#ER-Model" class="headerlink" title="ER Model"></a>ER Model</h2><p>What entities to model<br>How entities are related<br>What constraints exist in the domain<br>How to achieve good designs<br>Requirement analysis,Conceptual design(ER model),Logical/physical/security<br>Entity &amp; entity sets:entity are basic units of ER model, has several attributes.(eg:product:color,name,company); Key:unique attribute that defined a entity.<br>Relationship:between 2 entities. subset of all p,Q pairs with tuples uniquly defined by their keys. Use a new entity instead of relationship, and can make it expand.<br>Define subclass in ER,maintains connection with parent class,contains all attributes of parent class and add new attributes.<br>Difference with OODesign:OO classes are disjoint,ER entities sets overlap.</p><h2 id="Design-theory"><a href="#Design-theory" class="headerlink" title="Design theory"></a>Design theory</h2><p>Norm-forms(范式) and functionality dependency:<br>3rdNorm form(3NF):Boyce-Codd norm form.DB designs based on functional dependencies,intended to prevent data anomalies.<br>functional dependency:whenever 2 tuples agreed on A they agreed on B.A-&gt;B.<br>Use FD to find better schema and reduce anomaly.<br>Given set of FD, minimum FD and eliminate bad one.<br>Given a set of FD, does another fd holds?<br>methods:split/combine,reduction/trasivity.</p><h2 id="Buffer-manager"><a href="#Buffer-manager" class="headerlink" title="Buffer manager"></a>Buffer manager</h2><p>Operation:read/flush/release(withoutwriting to disks)<br>Core:<strong>External sorting algorithm</strong>,can use 3 pages to manage/merge lists of arbitrary length. If M,N length lists,2(M+N) IO operations.<br>problem:2 lists are both much larger that the main memory to merge directly.<br>How to sort big files?<br>1.Split chunks of small enough to sort in memory,<br>2.merge pairs of run using external sort algorithms.<br>3.keep merging the result untils only left with 1 list.</p><h2 id="Index-amp-B-tree"><a href="#Index-amp-B-tree" class="headerlink" title="Index &amp; B+ tree"></a>Index &amp; B+ tree</h2><p>Problem:get faster in search for specific attribute values;faster insertions.<br>Index is a data structure <strong>mapping search key(primary key) to each rows.provides efficient retrieval &amp; lookup.</strong><br>Operation:search,add/remove.<br>B+ tree: search tree,1 node for 1 page,balanced height adjusted.make leaves into a linkedlist.Leaf nodes contains pointer to data records, internal nodes points to other nodes which contains other slots.<br>Feature:high fan out.the depth of tree is small, can get to the nodes very fast.<br>self balancing:balanced with height even if after insert.</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>锁的粒度就是锁的作用范围，一般分为行级锁、表级锁。行级锁锁定记录行，表级锁锁定整个表。行级索：系统开销大，加锁慢，锁定粒度最小，会发生死锁，但是发生冲突的概率最低，并发性最高。表级索：系统开销小，加锁快，锁定粒度最大，不会发生死锁，但是发生冲突的概率最高，并发性最低。<br>共享锁只用于表级，排它锁用于行级或表级。<br>加了共享锁的对象，可以继续加共享锁，不能再加排他锁。<br>加了排他锁的对象，不能再加任何锁。<br>读写锁：共享锁，排它锁。<br>通常情况下，写操作较少时，使用乐观锁，写操作较多时，使用悲观锁。每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><h2 id="NoSQL的劣势和优势"><a href="#NoSQL的劣势和优势" class="headerlink" title="NoSQL的劣势和优势"></a>NoSQL的劣势和优势</h2><p>锁的粒度大，只支持全局读写锁，IO速度慢时容易造成卡死。<strong>不支持MySQL的事务操作，join多表查询困难。</strong><br>事务操作是指一批SQL语句具有相互关联性， 在一个表中插入删除了之后在另一个表里面也要进行相应的批处理操作，否则进行回滚。在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。<br>MySQL的事务操作机制：<br>1、用 BEGIN, ROLLBACK, COMMIT来实现<br>BEGIN 开始一个事务<br>ROLLBACK 事务回滚<br>COMMIT 事务确认<br>2、直接用 SET 来改变 MySQL 的自动提交模式:<br>SET AUTOCOMMIT=0 禁止自动提交<br>SET AUTOCOMMIT=1 开启自动提交</p><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><p>事务隔离级别是由谁实现的？<br>数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cover materials on Stanford CS145,345,346&lt;/p&gt;
&lt;h2 id=&quot;Transaction-Concurrency-amp-Atomicity&quot;&gt;&lt;a href=&quot;#Transaction-Concurrency-amp-Atomicity&quot; class=&quot;headerlink&quot; title=&quot;Transaction,Concurrency &amp;amp; Atomicity&quot;&gt;&lt;/a&gt;Transaction,Concurrency &amp;amp; Atomicity&lt;/h2&gt;&lt;p&gt;Performace problem:Disk/SSD    access is slow,DBMS hide the latency by    doing more CPU work concurrently.&lt;br&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>JDBC ResultSet</title>
    <link href="http://yoursite.com/2018/02/03/JDBC%20ResultSet.html"/>
    <id>http://yoursite.com/2018/02/03/JDBC ResultSet.html</id>
    <published>2018-02-03T17:33:53.000Z</published>
    <updated>2018-03-01T16:49:53.861Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>结果集(ResultSet)是数据中查询结果返回的一种对象，可以说结果集是一个存储查询结果的对象，但是结果集并不仅仅具有存储的功能，他同时还具有操纵数据的功能，可能完成对数据的更新等。<br>结果集读取数据的方法主要是getXXX() ，他的参数可以使整型表示第几列（是从1开始的），还可以是列名。返回的是对应的XXX类型的值。如果对应那列时空值，XXX是对象的话返回XXX型的空值，如果XXX是数字类型，如Float等则返回0，boolean返回false。使用getString()可以返回所有的列的值，不过返回的都是字符串类型的。XXX可以代表的类型有：基本的数据类型如整型(int)，布尔型(Boolean)，浮点型(Float,Double)等，比特型（byte），还包括一些特殊的类型，如：日期类型（java.sql.Date），时间类型(java.sql.Time)，时间戳类型 (java.sql.Timestamp)，大数型(BigDecimal和BigInteger等)等。还可以使用getArray(int colindex/String columnname)，通过这个方法获得当前行中，colindex所在列的元素组成的对象的数组。使用getAsciiStream(<br>int colindex/String colname)可以获得该列对应的当前行的ascii流。也就是说所有的getXXX方法都是对当前行进行操作。<br>结果集从其使用的特点上可以分为四类，这四类的结果集的所具备的特点都是和Statement语句的创建有关，因为结果集是通过Statement语句执行后产生的，所以可以说，结果集具备何种特点，完全决定于Statement，当然我是说下面要将的四个特点，在Statement创建时包括三种类型。首先是无参数类型的，他对应的就是下面要介绍的基本的ResultSet对应的Statement。下面的代码中用到的Connection并没有对其初始化，变量conn代表的就是Connection对应的对象。SqlStr代表的是响应的SQL语句。<br>1.最基本的ResultSet。<br>之所以说是最基本的ResultSet是因为，这个ResultSet他起到的作用就是完成了查询结果的存储功能，而且只能读去一次，不能够来回的滚动读取。这种结果集的创建方式如下：<br>Statement st = conn.CreateStatement<br>ResultSet rs = Statement.excuteQuery(sqlStr);<br>由于这种结果集不支持，滚动的读去功能所以，如果获得这样一个结果集，只能使用它里面的next()方法，逐个的读去数据。<br>2.可滚动的ResultSet类型。<br>这个类型支持前后滚动取得纪录next（）、previous()，回到第一行first()，同时还支持要去的ResultSet中的第几行 absolute（int n），以及移动到相对当前行的第几行relative(int n)，要实现这样的ResultSet在创建Statement时用如下的方法。<br>Statement st = conn. createStatement (int resultSetType, int resultSetConcurrency)<br>ResultSet rs = st.executeQuery(sqlStr)<br>其中两个参数的意义是：<br>resultSetType 是设置 ResultSet 对象的类型可滚动，或者是不可滚动。取值如下：<br>       ResultSet.TYPE_FORWARD_ONLY 只能向前滚动<br>       ResultSet.TYPE_SCROLL_INSENSITIVE 和 Result.TYPE_SCROLL_SENSITIVE 这两个 方法都能够实现任意的前后滚动，使用各种移动的 ResultSet 指针的方法。二者的区别在于前者对于修改不敏感，而后者对于修改敏感。<br>resultSetConcurency 是设置 ResultSet 对象能够修改的，取值如下：<br>       ResultSet.CONCUR_READ_ONLY 设置为只读类型的参数。<br>       ResultSet.CONCUR_UPDATABLE 设置为可修改类型的参数。<br>所以如果只是想要可以滚动的类型的 Result 只要把 Statement 如下赋值就行了。<br>Statement st = conn.createStatement(Result.TYPE_SCROLL_INSENITIVE,<br>ResultSet.CONCUR_READ_ONLY);<br>ResultSet rs = st.excuteQuery(sqlStr) ； </p><p>用这个 Statement 执行的查询语句得到的就是可滚动的 ResultSet 。<br>3.可更新的ResultSet<br>这样的ResultSet对象可以完成对数据库中表的修改，但是我知道ResultSet只是相当于数据库中表的视图，所以并不时所有的ResultSet只要设置了可更新就能够完成更新的，能够完成更新的ResultSet的SQL语句必须要具备如下的属性：<br>a.只引用了单个表。<br>b.不含有join或者group by子句。<br>c.那些列中要包含主关键字。<br>具有上述条件的，可更新的ResultSet可以完成对数据的修改，可更新的结果集的创建方法是：<br>Statement st = createstatement(Result.TYPE_SCROLL_INSENSITIVE,Result.CONCUR_UPDATABLE)<br>4、可保持的ResultSet<br>正常情况下如果使用Statement执行完一个查询，又去执行另一个查询时这时候第一个查询的结果集就会被关闭，也就是说，所有的Statement的查询对应的结果集是一个，如果调用Connection的commit()方法也会关闭结果集。可保持性就是指当ResultSet的结果被提交时，是被关闭还是不被关闭。JDBC2.0和1.0提供的都是提交后ResultSet就会被关闭。不过在JDBC3.0中，我们可以设置ResultSet是否关闭。要完成这样的ResultSet的对象的创建，要使用的Statement的创建要具有三个参数，这个Statement的创建方式也就是，我所说的 Statement的第三种创建方式。<br>当使用ResultSet的时候，当查询出来的数据集记录很多，有一千万条的时候，那rs所指的对象是否会占用很多内存，如果记录过多，那程序会不会把系统的内存用光呢<br>不会的，ResultSet表面看起来是一个记录集，其实这个对象中只是记录了结果集的相关信息，具体的记录并没有存放在对象中，具体的记录内容知道你通过next方法提取的时候，再通过相关的getXXXXX方法提取字段内容的时候才能从数据库中得到，这些并不会占用内存，具体消耗内存是由于你将记录集中的数据提取出来加入到你自己的集合中的时候才会发生，如果你没有使用集合记录所有的记录就不会发生消耗内存厉害的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;结果集(ResultSet)是数据中查询结果返回的一种对象，可以说结果集是一个存储查询结果的对象，但是结果集并不仅仅具有存储的功能，他同时还具有操纵数据的功能，可能完成对数据
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java Socket Programming</title>
    <link href="http://yoursite.com/2018/02/02/Java%20Socket.html"/>
    <id>http://yoursite.com/2018/02/02/Java Socket.html</id>
    <published>2018-02-02T22:07:08.000Z</published>
    <updated>2018-02-02T22:26:36.169Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Java-Socket-programming-basics"><a href="#Java-Socket-programming-basics" class="headerlink" title="Java Socket programming basics"></a>Java Socket programming basics</h2><p>URLs and URLConnections provide a relatively high-level mechanism for accessing resources on the Internet. Sometimes your programs require lower-level network communication, for example, when you want to write a client-server application.<br><a id="more"></a><br>The communication that occurs between the client and the server must be reliable. That is, no data can be dropped and it must arrive on the client side in the same order in which the server sent it.<br>TCP provides a reliable, point-to-point communication channel that client-server applications on the Internet use to communicate with each other. To communicate over TCP, a client program and a server program establish a connection to one another. Each program binds a socket to its end of the connection. To communicate, the client and the server each reads from and writes to the socket bound to the connection.</p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>An endpoint is a combination of an IP address and a port number. Every TCP connection can be uniquely identified by its two endpoints. That way you can have multiple connections between your host and the server.</p><p>The java.net package in the Java platform provides a class, Socket, that implements one side of a two-way connection between your Java program and another program on the network. The Socket class sits on top of a platform-dependent implementation, hiding the details of any particular system from your Java program. By using the java.net.Socket class instead of relying on native code, your Java programs can communicate over the network in a platform-independent fashion.</p><p>Additionally, java.net includes the ServerSocket class, which implements a socket that servers can use to listen for and accept connections to clients. This lesson shows you how to use the Socket and ServerSocket classes.</p><p><strong>If you are trying to connect to the Web, the URL class and related classes (URLConnection, URLEncoder) are probably more appropriate than the socket classes. In fact, URLs are a relatively high-level connection to the Web and use sockets as part of the underlying implementation. See Working with URLs for information about connecting to the Web via URLs.</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-Socket-programming-basics&quot;&gt;&lt;a href=&quot;#Java-Socket-programming-basics&quot; class=&quot;headerlink&quot; title=&quot;Java Socket programming basics&quot;&gt;&lt;/a&gt;Java Socket programming basics&lt;/h2&gt;&lt;p&gt;URLs and URLConnections provide a relatively high-level mechanism for accessing resources on the Internet. Sometimes your programs require lower-level network communication, for example, when you want to write a client-server application.&lt;br&gt;
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Advanced Sql query</title>
    <link href="http://yoursite.com/2018/02/02/Advanced-Sql-query.html"/>
    <id>http://yoursite.com/2018/02/02/Advanced-Sql-query.html</id>
    <published>2018-02-02T16:55:13.000Z</published>
    <updated>2018-02-04T05:04:29.355Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Query-Construction"><a href="#Query-Construction" class="headerlink" title="Query Construction"></a>Query Construction</h2><a id="more"></a><p>Make the filter condition as much complicate as you want. But may get some improvement in rewriting in the future to improve efficiency.<br>The naming of variables are important for multiple queries, actually several variables you use to construct the conditions are equivalant in their position. For example, <code>SELECT C.* FROM streets C,streets D,streets E WHERE C.B=D.A AND D.B=E.A AND E.B=C.A;</code> will give you all edges that cause the cycle, not just the single edge you indicate in the writing forms.</p><h2 id="Interesting-concurrency-problem"><a href="#Interesting-concurrency-problem" class="headerlink" title="Interesting concurrency problem"></a>Interesting concurrency problem</h2><p>Sqlite is light-weight database, and only support Locks based on <strong>Library level</strong>, thus not approraited to <strong>High concurrency</strong> situation. Each time only supports 1 write operation. If 2 process try to write at the same time will get you <em>DB is locked</em>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Query-Construction&quot;&gt;&lt;a href=&quot;#Query-Construction&quot; class=&quot;headerlink&quot; title=&quot;Query Construction&quot;&gt;&lt;/a&gt;Query Construction&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Database" scheme="http://yoursite.com/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>Computer Network week1</title>
    <link href="http://yoursite.com/2018/01/31/Computer-Network-week1.html"/>
    <id>http://yoursite.com/2018/01/31/Computer-Network-week1.html</id>
    <published>2018-01-31T22:07:08.000Z</published>
    <updated>2018-03-02T14:56:43.618Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Switch-amp-amp-Bridges"><a href="#Switch-amp-amp-Bridges" class="headerlink" title="Switch &amp;&amp; Bridges"></a>Switch &amp;&amp; Bridges</h2><a id="more"></a><p>The core job of a switch is to take packets that arrive on an input and forward them to the right output so that they will reach their appropriate destination. There are a variety of ways that the switch can determine the “right” output for a packet, which can be broadly categorized as connectionless and connection oriented approaches.<br>A switch is a multi-input, multi-output device that transfers packets from an input to one or more outputs. Thus, a switch adds the <strong>star topology</strong> to the P2P network.<br>switched networks are considered more scalable (i.e., more capable of growing to large numbers of nodes) than shared-media networks because of this ability to support many hosts at full speed.<br>A switch’s primary job is to receive incoming packets on one of its links and to transmit them on some other link. This function is sometimes referred to as either <strong>switching or forwarding.</strong>Main function of the network layer.<br>How does a packet decides where to go?<br>Using the header of the packet to determine. The first is the datagram or <strong>connectionless</strong> approach. The second is the virtual circuit or <strong>connection-oriented</strong> approach.<br>How to identify the end addrress of a packet?<br>48-bit addresses used for Ethernet, which is unique for all nodes. Use the number of port to identify input and output of switch.(二层交换机，就要使用二层Ethernet协议寻找地址)</p><h2 id="Datagrams-amp-amp-Virtual-circuit"><a href="#Datagrams-amp-amp-Virtual-circuit" class="headerlink" title="Datagrams &amp;&amp; Virtual circuit"></a>Datagrams &amp;&amp; Virtual circuit</h2><p>Datagrams:switch uses a forwarding table.A host can send a packet anywhere at any time, since any packet that turns up at a switch can be immediately forwarded. 2 same packets may follow different paths.<br>VC:conection oriented appraoch, requires setting up a virtual connection from the source host to the destination host before any data is sent. This is a two-stage process. The first stage is “connection setup.” The second is data transfer.<br>switch which connection bypasses will record all information in <strong>VC table.</strong>,includes VCI,incoming interface&amp;outgoing interface.<br>A virtual circuit identifier (VCI) that uniquely identifies the<br>connection at this switch and which will be carried inside the<br>header of the packets that belong to this connection. Packets sent out according to corresponding interface.；链接建立后每次发送的消息报头都会携带VCI信息字段。每次经过一个节点更新VCI。最后发送返回确认信息回到源节点。<br>链接断开后，switch会移除相应的entry。<br>每个switch记录信息，switch使用没使用过的VCI记录entry,packet outgoing. VCI：link scope。<br>建立连接的方式：1.Administrator configure.<br>VC:需要保证不同的QoS。</p><h2 id="ATM"><a href="#ATM" class="headerlink" title="ATM"></a>ATM</h2><p>ATM是virtual circuit最典型的应用，尽管现在deploy的已经很少了。ATM cell==ATM packet.<br>small fixed-length packets which only contaisn 54bytes. too short,large head overhead;too long,padding data to waste bandwidth.</p><h2 id="Bridges-amp-LAN-switches"><a href="#Bridges-amp-LAN-switches" class="headerlink" title="Bridges &amp; LAN switches"></a>Bridges &amp; LAN switches</h2><p>They are the same defnition. Use multi-input/output,1 input will flow ot all output. Thus can <strong>increase bandwidth of network.</strong>Be extended to #number of ports Mbps throughtput.<br>bridge takes self-learning and timeout mechanism to continually remove entries and add entries to the table.record which host is connected to which port.<br><strong>Spanning tree algorithms</strong><br>Avoid loop. subsets of original topological with no loops.</p><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>Use IP to solve heterogenioty in network by defining simple,common internetwork model. Then use ARP to resolve global IP address to a local linklayer IP address.<br>IP routing algorithm:determine efficient route to any destination.<br>Link state:RIP<br>distance vector:OSPF<br>Switch&amp;Bridges usually need to be scalable to deal with special situations.</p><h2 id="Mininet"><a href="#Mininet" class="headerlink" title="Mininet"></a>Mininet</h2><p>According to the [Mininet website]:<a href="http://mininet.org/" target="_blank" rel="noopener">http://mininet.org/</a>, Mininet creates a realistic virtual network, running real kernel, switch and application code, on a single machine (VM or native), in seconds, with a single command. We will use Mininet in programming assignments throughout the semester.<br><code>$</code> preceeds Linux commands that should be typed at the shell prompt<br><code>mininet&gt;</code> preceeds Mininet commands that should be typed at Mininet’s CLI,<br><code>#</code> preceeds Linux commands that are typed at a root shell prompt<br>The default topology is the minimal topology, which includes one OpenFlow kernel switch connected to two hosts, plus the OpenFlow reference controller. This topology could also be specified on the command line with <strong>–topo=minimal.</strong> Other topologies are also available out of the box; see the –topo section in the output of mn -h.<br>If the first string typed into the Mininet CLI is a host, switch or controller name, the command is executed on that node. Run a command on a host process:<code>h1 ifconfig -a</code>.<br>Note that only the network is virtualized; <strong>each host process sees the same set of processes and directories.</strong> For example, print the process list from a host process:<br>h1 ping -c #packets h2, ping from 1 host to another host.<br>Mininet hosts can run any command or application that is available to the underlying Linux system (or VM) and its file system. You can also enter any bash command, including job control (&amp;, jobs, kill, etc..)</p><p>You don’t need to drop into the CLI; Mininet can also be used to run self-contained regression tests.<br>Run a regression test:<code>sudo mn --test pingpair</code></p><p><code>sudo mn --test iperf</code><br>This command created the same Mininet, ran an iperf server on one host, ran an iperf client on the second host, and parsed the bandwidth achieved.</p><h2 id="Spanning-tree-algorithm"><a href="#Spanning-tree-algorithm" class="headerlink" title="Spanning-tree algorithm"></a>Spanning-tree algorithm</h2><p>Each bridge has a unique idetifier, first selects the bridge with the smallest id as the root of spanning tree.The root bridges always forward all its port.Next, each bridges compute its shortest path to the root and notes which of port is on the path. If equally close to the root, selects bridges with the smallest ID.<br>Each bridge records the current best configuration message it has seen on each of its ports.<br>Unicast &amp; Broadcast, Multicast<br>multicast:each port decides whether accept the message or not. Learns this by observing the source address of the packets that it receives over this port.<br>extended LANs don’t scale well because some LANS don’t want to be bothered by other broadcast messages.<br>One solution to scale is to use <strong>VLAN</strong>. a single extended LAN be partitioned into several LAN. assingned color/idetifier to each LAN segments and limit the number of segments in an extended LAN that will receive any given broadcast message.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Switch-amp-amp-Bridges&quot;&gt;&lt;a href=&quot;#Switch-amp-amp-Bridges&quot; class=&quot;headerlink&quot; title=&quot;Switch &amp;amp;&amp;amp; Bridges&quot;&gt;&lt;/a&gt;Switch &amp;amp;&amp;amp; Bridges&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>SSM framework summary</title>
    <link href="http://yoursite.com/2018/01/30/SSM-framework-summary.html"/>
    <id>http://yoursite.com/2018/01/30/SSM-framework-summary.html</id>
    <published>2018-01-31T01:34:59.000Z</published>
    <updated>2018-02-06T05:34:29.218Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IOC:Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。<br>IOC is a thought in SE,Dependency injection is a design pattern.<br>采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。而具体获取的方法、对象被获取时的状态由配置文件（如XML）来指定。</p><h2 id="Implement-methods"><a href="#Implement-methods" class="headerlink" title="Implement methods"></a>Implement methods</h2><p>1.基于接口。实现特定接口以供外部容器注入所依赖类型的对象。<br>2.基于 getter/setter 方法。实现特定属性的public set方法，来让外部容器调用传入所依赖类型的对象。<br>3.基于构造函数。实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。<br>4.基于注解。基于Java的注解功能，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而并不希望其他依赖此类的对象访问）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC&quot;&gt;&lt;/a&gt;IOC&lt;/h2&gt;&lt;p&gt;IOC:Class A中用到了C
      
    
    </summary>
    
    
      <category term="Java EE" scheme="http://yoursite.com/tags/Java-EE/"/>
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>OOD concepts</title>
    <link href="http://yoursite.com/2018/01/30/OOD-concepts.html"/>
    <id>http://yoursite.com/2018/01/30/OOD-concepts.html</id>
    <published>2018-01-31T01:17:21.000Z</published>
    <updated>2018-01-31T01:30:47.419Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="OOD-core-concepts"><a href="#OOD-core-concepts" class="headerlink" title="OOD core concepts"></a>OOD core concepts</h2><p>1.Excapsulation<br>2.Inheritence:子类只能继承父类部分的方法和对象。<br>3.Polyphosim:父类引用可以持有子类对象，只能调用父类的方法，不能调用特有方法。多态的实现：1.继承，多个子类重写2.接口，多种实现。</p><h2 id="Difference-between-Abstract-class-amp-amp-Interface"><a href="#Difference-between-Abstract-class-amp-amp-Interface" class="headerlink" title="Difference between Abstract class &amp;&amp; Interface"></a>Difference between Abstract class &amp;&amp; Interface</h2><p>1.single extends&amp;&amp;multi implementation<br>2.Abstract can have unabstract methods,interface can only have abstract methods. interface assumes methods:<strong>public static final</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;OOD-core-concepts&quot;&gt;&lt;a href=&quot;#OOD-core-concepts&quot; class=&quot;headerlink&quot; title=&quot;OOD core
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java load balancing</title>
    <link href="http://yoursite.com/2018/01/30/Java-load-balancing.html"/>
    <id>http://yoursite.com/2018/01/30/Java-load-balancing.html</id>
    <published>2018-01-31T01:10:01.000Z</published>
    <updated>2018-01-31T01:12:02.185Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Load-Balancing-Algorithms"><a href="#Load-Balancing-Algorithms" class="headerlink" title="Load Balancing Algorithms"></a>Load Balancing Algorithms</h2><p>Round robin:equally divide sevaral number of tasks.<br>Weighted RR:assign different number of tasks to several servers according to the weights.<br>Random<br>最少连接（Least Connections）<br>记录每个应用服务器正在处理额连接数（请求数），将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Load-Balancing-Algorithms&quot;&gt;&lt;a href=&quot;#Load-Balancing-Algorithms&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java multithread programming</title>
    <link href="http://yoursite.com/2018/01/30/Java-multithread-programming.html"/>
    <id>http://yoursite.com/2018/01/30/Java-multithread-programming.html</id>
    <published>2018-01-30T22:47:16.000Z</published>
    <updated>2018-03-02T17:01:28.437Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Multithreading-implementation"><a href="#Multithreading-implementation" class="headerlink" title="Multithreading implementation"></a>Multithreading implementation</h2><p>2 ways to implement multithreading:1.implement Runnable, then implement the void run() method.2.extends the Thread abstract class.<br>Obviously 1st way is better, as Java not allowed extends multi-classes.</p><h2 id="Java-util-concurrent"><a href="#Java-util-concurrent" class="headerlink" title="Java.util.concurrent"></a>Java.util.concurrent</h2><p>It includes several threadsafing collection framework:CopyOnWriteArrayList,ConcurrentHashMap,ConcurrentSkipListSet,ConcurrentSkipListMap,BlockingQueue<br>Eg:BlockingQueue is thread safe for consumer/producer problems. Whereas add, remove will <strong>throw Exception</strong>; offer poll gives out specail value; put/take will get thread blocked until operated successfully.<br>ConcurrentHashMap providing thread safety and <strong>atomicity</strong> guarantees.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer  c= <span class="keyword">new</span> Consumer();</span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer();</span><br><span class="line">        <span class="keyword">new</span> Thread(c).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(p).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>tasks may execute in a newly created thread, an existing task-execution thread, or the thread calling execute, and may execute sequentially or concurrently.<br>ThreadPoolExecutor and ScheduledThreadPoolExecutor provide tunable, flexible thread pools. The Executors class provides factory methods for the most common kinds and configurations of Executors, as well as a few utility methods for using them. Other utilities based on Executors include the concrete class FutureTask providing a common extensible implementation of Futures, and ExecutorCompletionService, that assists in coordinating the processing of groups of asynchronous tasks.<br>Implements the <strong>ThreadFactory</strong> can creates self serving thread class.</p><h2 id="Lock-in-Java"><a href="#Lock-in-Java" class="headerlink" title="Lock in Java"></a>Lock in Java</h2><p>ReentrantLock 实现的锁定规则非常简单 – 每当一个线程具有锁定时，其他线程必须等待，直到该锁定可用。有时，当对数据结构的读取通常多于修改时，可以使用更复杂的称为读写锁定的锁定结构，它允许有多个并发读者，同时还允许一个写入者独占锁定。该方法在一般情况下（只读）提供了更大的并发性，同时在必要时仍提供独占访问的安全性。ReadWriteLock 接口和 ReentrantReadWriteLock 类提供这种功能 – 多读者、单写入者锁定规则，可以用这种功能来保护共享的易变资源。<br>synchoronized used for methods/coding blocks.synchormized(this){}.非同步代码仍然能继续执行。<strong>synchronized锁住的是括号里的对象，而不是代码</strong>。main()里面只创建一个new Thread(),thread.start()同步机制才会生效.多个thread是不生效的。synchronized(Sync.class)实现全局锁的效果。</p><h2 id="Java-util-concurrent-atomic-locks"><a href="#Java-util-concurrent-atomic-locks" class="headerlink" title="Java.util.concurrent.atomic/locks"></a>Java.util.concurrent.atomic/locks</h2><h2 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h2><p>Servlet is singleton but multi-threading, and is not thread safe.</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>ConcurrentHashMap是J.U.C(java.util.concurrent包)的重要成员，它是HashMap的一个线程安全的、支持高效并发的版本。在默认理想状态下，ConcurrentHashMap可以支持<strong>16个线程执行并发写操作</strong>及任意数量线程的读操作。<br>在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。特别地，在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设为16），及任意数量线程的读操作。</p><ul><li>通过锁分段技术保证并发环境下的写操作；</li><li>通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作；</li><li>通过不加锁和加锁两种方案控制跨段操作的的安全性。<br>ConcurrentHashMap读操作不需要加锁的奥秘在于以下三点：<br>用HashEntery对象的不变性来降低读操作对加锁的需求；<br>用Volatile变量协调读写线程间的内存可见性；<br>若读时发生指令重排序现象，则加锁重读；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Multithreading-implementation&quot;&gt;&lt;a href=&quot;#Multithreading-implementation&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode daily practice-Array</title>
    <link href="http://yoursite.com/2018/01/30/leetcode-daily-practice-Array.html"/>
    <id>http://yoursite.com/2018/01/30/leetcode-daily-practice-Array.html</id>
    <published>2018-01-30T18:24:28.000Z</published>
    <updated>2018-01-30T18:28:26.975Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Array-manipulation"><a href="#Array-manipulation" class="headerlink" title="Array manipulation"></a>Array manipulation</h2><p>I often feel tricky with many Array manipulation problems. This post may get updated in the future. Currently just can recognize to use increasing stack to solve this kind of typical problems.</p><h2 id="Increasing-Stack"><a href="#Increasing-Stack" class="headerlink" title="Increasing Stack"></a>Increasing Stack</h2><p>To keep the order of the array and records some position information of the array.<br>lc739. Daily Temperatures<br>Use a stack to keep compare the peek element and current element, then get the position value of each position.<br>lc .Rectangle Histogram</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;Array-manipulation&quot;&gt;&lt;a href=&quot;#Array-manipulation&quot; class=&quot;headerlink&quot; title=&quot;Array 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="stack" scheme="http://yoursite.com/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Call, apply</title>
    <link href="http://yoursite.com/2018/01/22/Call-apply.html"/>
    <id>http://yoursite.com/2018/01/22/Call-apply.html</id>
    <published>2018-01-23T00:38:30.000Z</published>
    <updated>2018-03-06T14:58:35.055Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>前端面试中，很多面试官会问你，apply是做什么的？apply和call的区别？<br><a id="more"></a><br>你可以告诉面试官，apply和call只有一个区别，就是传入的参数格式不同，apply传入一个数组参数 [argsArray]，而call传入参数列表 arg1, arg2, …<br>1.Apply的语法结构<br>有2个参数<br>thisArg：在 fun 函数运行时指定的 this 值，非严格模式下，也就是没有写”use strict”，<strong>通常这个值设置为null或者undefined，则指向全局对象（大部分是时候是window）</strong>。<br>argsArray：数组对象或者类数组对象，类数组对象只支持ES5，你可以不传任何参数，则为null 或 undefined。<br><code>fun.apply(thisArg, [argsArray])</code>.<br>2.使用apply和内置函数：内置函数有很多，比如Array实现的内置函数、Math实现的内置函数<br>使用apply调用Array的内置函数push()，可以写成下面这样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//第一个参数表示正在调用调用push()的对象，这行代码的意思是说把arr2的参数传入arr1，你可以看成是arr1.push(arr2)这种行为，但不是等价的。</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2)  <span class="comment">//[1, 3, 4, 2, 4, 5]</span></span><br><span class="line"><span class="comment">//类似下面这种写法，他们的输出是一样的。</span></span><br><span class="line">arr2.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">arr1.push(value)</span><br><span class="line">&#125;) <span class="comment">// [1, 3, 4, 2, 4, 5]</span></span><br><span class="line"><span class="keyword">var</span> num = [<span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, num); <span class="comment">// null说明当前函数执行的上下文是在全局作用域，输出10</span></span><br></pre></td></tr></table></figure><br><strong>总结：apply作为内置函数调用传参是最经常使用的场景，唯一的难点在于指定第一个参数的运行环境，毕竟一个this可以难倒一大批前端工程师。</strong></p><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>使用call方法调用匿名函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> people = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'阿里妈妈'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'阿里爸爸'</span>, <span class="attr">age</span>: <span class="number">22</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="comment">//一开始你可能会这样写：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; </span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.age); </span><br><span class="line">        &#125;, i * <span class="number">1000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125; <span class="comment">//输出 </span></span><br><span class="line"><span class="comment">//"JS Bin Output : undefined"</span></span><br><span class="line"><span class="comment">//"JS Bin Output : undefined"</span></span><br></pre></td></tr></table></figure><br>然后发现this指向不对，你可能会想到给函数设置一个变量指向当前的this，但是这样也不对，因为输出的this.name和this.age是指向数组animals的对象，那么这时候你需要给匿名函数用到call来绑定this指向的是animals里面循环的对象。然而你会发现输出还是undefined，为什么呢？<br>原因在于匿名函数里面的this是指向了people[i]的对象，但是setTimeout里面的this是指向window的，所以你需要用到bind()绑定this。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; </span><br><span class="line"><span class="comment">//这里也可以用var  _this = this来改变this的上下文（指向）</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">          <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">': '</span> + <span class="keyword">this</span>.age); </span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>), i * <span class="number">1000</span>)</span><br><span class="line">    &#125;).call(people[i], i);</span><br><span class="line">&#125; <span class="comment">//输出</span></span><br><span class="line"><span class="comment">//"阿里妈妈: 18"</span></span><br><span class="line"><span class="comment">//"阿里爸爸: 22"</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;apply&quot;&gt;&lt;a href=&quot;#apply&quot; class=&quot;headerlink&quot; title=&quot;apply&quot;&gt;&lt;/a&gt;apply&lt;/h3&gt;&lt;p&gt;前端面试中，很多面试官会问你，apply是做什么的？apply和call的区别？&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>Spread Operator</title>
    <link href="http://yoursite.com/2018/01/22/Spread-Operator.html"/>
    <id>http://yoursite.com/2018/01/22/Spread-Operator.html</id>
    <published>2018-01-23T00:29:47.000Z</published>
    <updated>2018-03-06T15:39:01.324Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>JavaScript是ECMAScript的实现和扩展，ES6标准的制定也为JavaScript加入了许多新特性。本文主要记录展开运算符。</p><p>展开运算符（spread operator）允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。<br><a id="more"></a><br>展开运算符不能用在对象当中，因为目前展开运算符只能在可遍历对象（iterables）可用。iterables的实现是依靠[Symbol.iterator]函数，而目前只有Array,Set,String内置[Symbol.iterator]方法，而Object尚未内置该方法，因此无法使用展开运算符。不过ES7草案当中已经加入了对象展开运算符特性。</p><h3 id="函数调用中使用展开运算符"><a href="#函数调用中使用展开运算符" class="headerlink" title="函数调用中使用展开运算符"></a>函数调用中使用展开运算符</h3><p>在以前我们会使用apply方法来将一个数组展开成多个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b, c</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">test.apply(<span class="literal">null</span>, args);</span><br></pre></td></tr></table></figure><br>如上，我们把args数组当作实参传递给了a,b,c，这边正是利用了Function.prototype.apply的特性。</p><p>不过有了ES6，我们就可以更加简洁地来传递数组参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c</span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">test(...args);</span><br></pre></td></tr></table></figure></p><h3 id="数组字面量中使用展开运算符"><a href="#数组字面量中使用展开运算符" class="headerlink" title="数组字面量中使用展开运算符"></a>数组字面量中使用展开运算符</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[...arr1,<span class="string">'d'</span>,<span class="string">'e'</span>]; <span class="comment">//['a','b','c','d','e']</span></span><br></pre></td></tr></table></figure><h3 id="用于解构赋值"><a href="#用于解构赋值" class="headerlink" title="用于解构赋值"></a>用于解构赋值</h3><p><code>let [pivot,...rest] = arr</code>.只能用在数组最后。<br>剩余对象必须用在最后，…spread可以用在中间。</p><h3 id="类数组对象变成数组"><a href="#类数组对象变成数组" class="headerlink" title="类数组对象变成数组"></a>类数组对象变成数组</h3><p>展开运算符可以将一个类数组对象变成一个真正的数组对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> arr=[...list];</span><br></pre></td></tr></table></figure></p><h3 id="ES7草案中的对象展开运算符"><a href="#ES7草案中的对象展开运算符" class="headerlink" title="ES7草案中的对象展开运算符"></a>ES7草案中的对象展开运算符</h3><p>spread可以对对象进行操作，提取对象中的元素。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x,y,...z&#125;=&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>,<span class="attr">a</span>:<span class="number">3</span>,<span class="attr">b</span>:<span class="number">4</span>&#125;;</span><br><span class="line">x; <span class="comment">//1</span></span><br><span class="line">y; <span class="comment">//2</span></span><br><span class="line">z; <span class="comment">//&#123;a:3,b:4&#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript是ECMAScript的实现和扩展，ES6标准的制定也为JavaScript加入了许多新特性。本文主要记录展开运算符。&lt;/p&gt;
&lt;p&gt;展开运算符（spread operator）允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>阴雨天的新学期</title>
    <link href="http://yoursite.com/2018/01/22/%E9%98%B4%E9%9B%A8%E5%A4%A9%E7%9A%84%E6%96%B0%E5%AD%A6%E6%9C%9F.html"/>
    <id>http://yoursite.com/2018/01/22/阴雨天的新学期.html</id>
    <published>2018-01-22T14:43:36.000Z</published>
    <updated>2018-01-25T04:08:31.788Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="新学期换个心情生活"><a href="#新学期换个心情生活" class="headerlink" title="新学期换个心情生活"></a>新学期换个心情生活</h2><p>麦屯淅淅沥沥下了一夜的雨，我也一夜都没睡好。希望新学期认真上课，好好做项目，能少一点来自现实的压力，希望暑假早一点到来，毕竟这个寒假实在是太煎熬了。<br><a id="more"></a></p><h2 id="音乐分享"><a href="#音乐分享" class="headerlink" title="音乐分享"></a>音乐分享</h2><p>日经安利贴。忙到没有时间看综艺节目了，但是刷微博还是看到张韶涵在《歌手》的翻唱刷了屏。虽然上了高中以后就听古风听得多了，但是有些音乐什么时候想起来都是那段生活的回忆吧，比如初三初四最拼的时候，听广播里放一首《隐形的翅膀》就觉得特别励志，然后自我安慰着自己那与投入不成正比的努力，后来这首歌出现在北京高考作文试题里，让在那个年纪天天沉迷高考满分作文的我对这首歌愈发喜爱。它代表了一种坚持和希望吧，正如歌词所写：<strong>愿所有梦想都开花</strong>。再比如在北欧看极光的时候放一首《欧若拉》也是极其应景的，其他诸如《看得最远的地方》《遗失的美好》不一而足。<br>想来《隐形的翅膀》也是她自己人生的写照吧，虽然历经种种波折指责，在人生的最高峰最辉煌的时刻跌落，但是只要心中有坚定的信念和对生活的憧憬，终有一天能看到梦想的绽放。<br><blockquote><p>每一次都在徘徊孤单中坚强<br>每一次就算很受伤也不闪泪光<br>我知道我一直有双隐形的翅膀<br>带我飞飞过绝望<br>不去想他们拥有美丽的太阳<br>我看见每天的夕阳也会有变化<br>我知道我一直有双隐形的翅膀<br>带我飞给我希望</p></blockquote></p><div class="aplayer" data-id="36871866" data-server="netease" data-type="song"></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;新学期换个心情生活&quot;&gt;&lt;a href=&quot;#新学期换个心情生活&quot; class=&quot;headerlink&quot; title=&quot;新学期换个心情生活&quot;&gt;&lt;/a&gt;新学期换个心情生活&lt;/h2&gt;&lt;p&gt;麦屯淅淅沥沥下了一夜的雨，我也一夜都没睡好。希望新学期认真上课，好好做项目，能少一点来自现实的压力，希望暑假早一点到来，毕竟这个寒假实在是太煎熬了。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="音乐" scheme="http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>React review</title>
    <link href="http://yoursite.com/2018/01/19/React%20review.html"/>
    <id>http://yoursite.com/2018/01/19/React review.html</id>
    <published>2018-01-19T23:05:18.000Z</published>
    <updated>2018-03-06T16:09:55.978Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="React解决了什么问题"><a href="#React解决了什么问题" class="headerlink" title="React解决了什么问题"></a>React解决了什么问题</h2><p>MVC架构的双向绑定以及一对多的关系容易造成连级/联动（Cascading）修改，对于代码的调试和维护都成问题。<a href="https://zhuanlan.zhihu.com/p/21324696" target="_blank" rel="noopener">Problem</a><br><a id="more"></a></p><h2 id="如何设计一个好的Component"><a href="#如何设计一个好的Component" class="headerlink" title="如何设计一个好的Component"></a>如何设计一个好的Component</h2><p>高内聚，低耦合<br>React组件设计推崇的是“组合”，而非“继承”。例如你的页面需要一个表单组件，表单中需要有输入框，按钮，列表，单选框等。那么在开发中你不应该只开发一（整）个表单组件（<form>），而是应该开发若干个单一功能的组件，比如输入框<input>、提交按钮<submit>、单选框<checkbox>等，最后再将它们组合起来。这其中的重点是<strong>每个组件仅做一件事</strong>。<br>设计模式：Higher-Order Components 和 Container Components 和 Stateless Components.</checkbox></submit></form></p><h2 id="什么时候render调用，什么时候修改DOM"><a href="#什么时候render调用，什么时候修改DOM" class="headerlink" title="什么时候render调用，什么时候修改DOM"></a>什么时候render调用，什么时候修改DOM</h2><p>毫无疑问Render是在组件 state 发生改变时候被调用。无论是通过 setState 函数改变组件自身的state值，还是继承的 props 属性发生改变都会造成render函数被调用，即使改变的前后值都是一样的。shouldComponentUpdate默认都返回true，可以重写进行优化。<br>React组件中存在两类DOM，一类是众所周知的Virtual DOM，相信大家也耳熟能详了；另一类就是浏览器中的真实DOM（Real DOM/Native DOM）。React的Render函数被调用之后，React立即根据props或者state重新创建了一颗Virtual DOM Tree，虽然每一次调用时都重新创建，但因为在内存中创建DOM树其实是非常快且不影响性能的，所以这一步的开销并不大。而Virtual DOM的更新并不意味这Real DOM的更新，接下来的事情也是大家知道的，React采用算法将Virtual DOM和Real DOM进行对比，找出需要更新的最小步骤，此时Real DOM才可能发生修改。每一次的state更改都会使得render函数被调用，但页面的DOM不一定会发生修改</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Mounting, Updating, Unmounting.<br>Mounting:<br>constructor,componentWillMount(在mount前调用可操作state),render(只能渲染DOM),componentDidMount(<strong>如果你有第三方操作DOM的类库需要初始化（类似于jQuery，Bootstrap的一些组件）操作DOM、或者请求异步数据，都应该放在这个步骤中做</strong>)<br>Updating:<br>componentWillReceiveProps,在这里你可以拿到即将改变的状态，可以在这一步中通过setState方法设置state;shouldComponentUpdate,<strong>componentWillUpdate(不能改变state)</strong>;render();componentDidUpdate,更新DOM执行请求.<br><strong>componentWillReceiveProps()提供了该流程中更新state的最后时机，后续的其他函数都不能再更新组件的state了</strong>。我们尤其需要注意的是shouldComponentUpdate函数，它的结果直接影响该组件是不是需要进行虚拟DOM比较，我们对组件渲染性能优化的基本思路就是：在非必要的时候将shouldComponentUpdate返回值设置为false，从而终止更新DOM流程中的后续步骤。<br>Unmounting<br>componentWillUnmount<br>有哪些生命周期是允许设置state的？<br>React 提供了性能分析插件React.addons.Perf，它让我们可以在需要检测的代码起始位置分别添加Perf.start()和Perf.stop()，并可以通过Perf.printInclusive()方法打印花费时间，然后我们可以结合数据做进一步的分析。<br>虽然React提供了Virtual DOM DOM Diff 等优秀的能力来提高渲染性能，但是在实际使用过程中，<strong>我们经常会遇到父组件更新，不需要更新所有子组件的场景（分页）</strong>，此时必须考虑利用React本周的渲染机制来进行优化。</p><h2 id="React更新state时做了什么"><a href="#React更新state时做了什么" class="headerlink" title="React更新state时做了什么"></a>React更新state时做了什么</h2><p>React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，并且知道如何只通过必要的更新来最小化重渲染。</p><h2 id="Redux相关问题"><a href="#Redux相关问题" class="headerlink" title="Redux相关问题"></a>Redux相关问题</h2><p>React的批量更新机制 BatchUpdates？<br>Redux是如何将state注入到React组件上的？mapStateToProps,connect<br>请描述一次完整的 Redux 数据流<br>Redux是如何做到可预测呢？pure function,map State to action<br>Redux将React组件划分为哪两种？container,common UI component</p><h2 id="Webpack相关"><a href="#Webpack相关" class="headerlink" title="Webpack相关"></a>Webpack相关</h2><p>Webpack如何打包输出多个文件？<br>webpack打包时如何工作的？<br>如何解决循环引用的问题<br>在什么情况下需要打包输出多个文件？<br>loader和plugin的差别:loader 用于加载某些资源文件;plugin 用于扩展webpack的功能。它直接作用于 webpack，扩展了它的功能。<br>你觉得使用过什么高级技巧吗？</p><h2 id="React-redux链接问题"><a href="#React-redux链接问题" class="headerlink" title="React-redux链接问题"></a>React-redux链接问题</h2><p>connect(null,actions):将普通component注入reducer &amp;&amp; state使其变为container。bindActionCreators一般不在行为定义的时候进行行为绑定。bindActionCreators(action,dispatch);//action payload返回的时候promise解析成dispatch(res=&gt;dispatch({type:FETCH_USER,payload:res.data}));<br>According to oficial guide:<br>You might ask: why don’t we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won’t work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you’re stuck with a single store instance for all requests.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;React解决了什么问题&quot;&gt;&lt;a href=&quot;#React解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;React解决了什么问题&quot;&gt;&lt;/a&gt;React解决了什么问题&lt;/h2&gt;&lt;p&gt;MVC架构的双向绑定以及一对多的关系容易造成连级/联动（Cascading）修改，对于代码的调试和维护都成问题。&lt;a href=&quot;https://zhuanlan.zhihu.com/p/21324696&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Problem&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>转-面试感想</title>
    <link href="http://yoursite.com/2018/01/19/%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97.html"/>
    <id>http://yoursite.com/2018/01/19/面试心得.html</id>
    <published>2018-01-19T22:41:18.000Z</published>
    <updated>2018-01-31T05:58:18.427Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="转自知乎日报"><a href="#转自知乎日报" class="headerlink" title="转自知乎日报"></a>转自知乎日报</h2><a id="more"></a><p>如果你想去更大的平台发展，比如微软、阿里、Airbnb、亚马逊，即使是前端的岗位，在面试时（甚至每一轮）也会考验一些算法题目（虽然我觉得没什么道理）。总的来说面试算法题的公司一半一半吧，另一半倾向于面试前端相关的实战练习题。外企基本不考察你的前端能力，只考虑你的算法和数据结构能力（别问我是怎么知道的，我的面试史就是一部血泪史）。所以前端同学懂一些基本的算法也是有必要的。我不知道其他语言的程序员在找工作时面试的算法题有哪些，但前端的算法面试题还算是比较基础并且不难（至少相对于我而言）。我也算是面霸了，所以分享一些个人经验，同时也是记录下来写给将来的有需要的自己。</p><p>如果你有比较明确的方向，比如“我以后一定要做C++/Java方向的开发”，那么一定要强调出来。如果像阿里这样每个面试官都有个方向牌那很容易搞定，如果没有则可以在面试一开始的自我介绍或找其它机会说出来让面试官知道，可能有人认为语言不重要，关键是算法、数据结构、操作系统云云……是的，很多面试官都跟我说过：在以后的工作过程中，语言不重要，重要的是你以后做的东西是不是你感兴趣的，但是我认为语言在面试过程中是有非常大的关系的，如果你是C++方向，那么面试官可能会问你一些虚函数机制、Linux下的内存分配策略、内存管理、常用系统调用等这方面的知识；<strong>如果你主攻Java，可能会问集合类区别、可研究过jdk源码、数据库等方面的知识。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;转自知乎日报&quot;&gt;&lt;a href=&quot;#转自知乎日报&quot; class=&quot;headerlink&quot; title=&quot;转自知乎日报&quot;&gt;&lt;/a&gt;转自知乎日报&lt;/h2&gt;
    
    </summary>
    
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
      <category term="interview" scheme="http://yoursite.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>Understanding Promise</title>
    <link href="http://yoursite.com/2018/01/18/Understanding-Promise.html"/>
    <id>http://yoursite.com/2018/01/18/Understanding-Promise.html</id>
    <published>2018-01-18T22:16:47.000Z</published>
    <updated>2018-03-06T15:34:02.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>回调函数不允许使用return/throw, callback hell。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>ES6 原生提供了 Promise 对象。<br>所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。<br><a id="more"></a><br>Promise 对象有以下两个特点。</p><ul><li>对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。<strong>就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同</strong>，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li></ul><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><p><strong>当异步方法比如setTimeout()，或者ajax请求、DOM事件执行的时候，会交由浏览器内核的其他模块去管理。当异步的方法满足触发条件后，该模块就会将方法推入到一个任务队列（task queue）中，当主线程代码执行完毕处于空闲状态的时候，就会去检查任务队列，将队列中第一个任务入栈执行，完毕后继续检查任务队列，如此循环。前提条件是主线程处于空闲状态，这就是事件循环的模型.</strong><br>Timer2延迟100ms，所以会早于Timer1被添加到队列排头。而主线程此时处于空闲状态，所以会检查任务队列是否有待执行的任务。此时会将Timer2回调中的console.log()执行，控制台打印’world’，然后执行栈空闲后继续检查任务队列，将Timer1的代码压入执行栈中执行，控制台打印’hello’，清空执行栈，此时任务队列为空，执行结束。还是根据定时器时间决定哪个先进主线程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回调函数不允许使用return/throw, callback hell。&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;ES6 原生提供了 Promise 对象。&lt;br&gt;所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>Front-end basic</title>
    <link href="http://yoursite.com/2018/01/18/Front-end-basic.html"/>
    <id>http://yoursite.com/2018/01/18/Front-end-basic.html</id>
    <published>2018-01-18T18:26:50.000Z</published>
    <updated>2018-03-07T00:38:39.141Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="front-end-SEO"><a href="#front-end-SEO" class="headerlink" title="front-end SEO"></a>front-end SEO</h2><p>Search engine Optimization，具体方法包括：<br><a id="more"></a></p><ul><li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li><li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用js输出：爬虫不会执行js获取内容</li><li>少用iframe：搜索引擎不会抓取iframe中的内容</li><li>非装饰性图片必须加alt</li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标<br>How to do SEO optimization?</li><li>标题与关键词，设置有吸引力切合实际的标题，标题中要包含所做的关键词</li><li>网站结构目录，最好不要超过三级，每级有”面包屑导航”，使网站成树状结构分布</li><li>页面元素，给图片标注”Alt”可以让搜索引擎更友好的收录</li><li>网站内容，每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢</li><li>内链的布置，使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接</li><li>流量分析，通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO<h2 id="JS-knowledge"><a href="#JS-knowledge" class="headerlink" title="JS knowledge"></a>JS knowledge</h2></li></ul><ol><li>Array methods:isArray,slice,join,splice,shift(移除),unshift,push,pop,every,some,forEach,map,indexOf,lastIndexOf,concat,includes,reverse.splice返回移除的元素，reverse改变原数组</li><li>事件委托：利用冒泡的原理，把事件加到父级上，触发执行效果。同一类型事件只在父级元素添加一次。提高性能。<br>NodeJS性能优化：使用async并行执行，异步代码(NodeJS是单线程的)，缓存不经常用的数据：Redis模块，redis.createClient(),检查是否存在then读取并缓存。打包JS。Session不能存放太多数据：典型的 Express页面应用，Session数据默认是保存在内存中的。当你把太多数据保存在Session的时候，会导致服务器开销显著增大。</li><li>跨域问题：AJAX是同源策略，浏览器在请求不同域的资源时，会受到浏览器的同源策略影响，常常请求资源不成功。同源策略：浏览器限制脚本中发起的跨站请求，<strong>要求JavaScript或cookie只能访问同源的资源</strong>。这里的同源指的是，域名，协议名，以及端口号相同。 使用JSONP解决跨域问题，json是一种数据存储的基本格式，通常见于js脚本存储数据，ajax请求数据。而jsonp是一种非正式的传输协议，该协议的一个要点是允许用户传递一个callback参数给服务端，服务端返回数据时，会将callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。Jsonp的原理是：普通资源请求都会受到跨域影响，但含有src属性的跨域资源在调用时并不会受到影响。Jsonp就是由于这种特性被发掘并实现跨域的. 如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。只要响应头<code>Access-Control-Allow-Origin</code>为<a href="http://my.com，或者是*，本次请求就可以成功。可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的`Access-Control-Allow-Origin`，决定权始终在对方手中。" target="_blank" rel="noopener">http://my.com，或者是*，本次请求就可以成功。可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的`Access-Control-Allow-Origin`，决定权始终在对方手中。</a></li><li>AJAX技术：无需刷新页面就能够从服务器交换数据并更新部分网页的一种方法。出现使得向服务器请求额外的数据而无需卸载页面。停留在当前页面，用JS发送请求，再用JS获取数据，数据可以不断更新。最早使用的Gmail。要通过回调函数获得响应（异步的）。 request.onreadystatechange = function(){return success()}<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlh;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    xmlh = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    xmlh = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlh.open(<span class="string">"GET"</span>,url,<span class="literal">true</span>);</span><br><span class="line">xmlh.send();</span><br><span class="line">xmlh.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlh.readState == <span class="number">4</span>&amp;&amp;xmlh.status == <span class="number">200</span>) &#123;<span class="comment">//200OK,404Not found</span></span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"showbox"</span>).innerHTML=xmlh.resnponseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>JS事件循环<br>异步IO.NodeJS单线程。<br>当函数执行完毕后本地变量会从stack中弹出，这只有在使用numbers string boolean 这种基本数据类型时才会发生。<strong>而对象、数组的值是存在于heap(堆)中的，stack只存放了他们对应的指针。</strong><br>当函数之行结束从stack中弹出来时，只有对象的指针被弹出，<strong>而真正的值依然存在 heap 中，然后由垃圾回收器自动的清理回收。</strong><br>回调函数正在等待轮到自己执行所排的队就被称为任务队列(或者事件队列、消息队列)。每当主线程完成前一个任务，回调函数就会在一个无限循环圈里被调用，因此这个圈被称为事件循环。</li><li>函数声明能变成立即执行函数，函数表达式不行。声明：function fun(){}。<code>(function(a){console.log(a);   //firebug输出123,使用（）运算符})(123)</code>; <code>(function(){console.log(&#39;Hello World&#39;);})()</code>立即执行函数。</li><li>== for [] =false,[1] = true/1,{}(object)什么都不==/===<br>if([]==false){console.log(1)};<br>if({}==false){console.log(2)};<br>if([]){console.log(3)}<br>if([1]==[1]){console.log(4)}<br>// 只输出1,3</li><li>setTimeout(function() {<br>console.log(1)<br>}, 0);<br>new Promise(function executor(resolve) {<br>console.log(2);<br>for( var i=0 ; i&lt;10000 ; i++ ) {<br> i == 9999 &amp;&amp; resolve();<br>}<br>console.log(3);<br>}).then(function() {<br>console.log(4);<br>});<br>console.log(5);<br>// 2 3 5 4 1.Settimeout直接被压栈进入回调了。i==9999才resolve.<br>其实JS引擎在处理这段代码的时候，并不是真正的延迟0ms执行。<strong>不同的浏览器会默认有一个最小的延迟时间，低于这个时间间隔会按照默认最小的时间间隔来处理。</strong></li></ol><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ol><li>块级元素和行内元素有什么区别，举例常用的块级和行内元素，行内元素有padding/margin吗.没有margin/padding-top/bottom.行内元素设置width、height不起作用.行内元素:只占据它对应标签的边框所包含的空间.只能容纳文本或者其他内联元素.块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。通常浏览器会在块级元素前后另起一行。能容纳其他块元素或者内联元素。内联元素(input,strong,img,abbr,em,span,label)，和其他元素在一行。2.float 当把行内元素设置完float:left/right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。行内元素去除了之间的莫名空白。</li><li>call,apply,bind的区别，并举例使用的场景</li><li>画出一个正方形，并且自适应，列出的方法越多越好</li><li>父级元素下面无固定宽高的块元素，实现水平垂直居中.Flex<br>{<br> position:absolute;<br> top:50%;<br> left:50%;<br> transform:translate(-50%,-50%);<br>}</li><li>argument是数组吗？不是的话，怎么变成数组<br>不是，类数组对象，<code>var a=[].slice.call(argments)</code>.<br>[…arguments],Array.prototype.slice.call(arguments)<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2></li><li>CSS3.0 new feature: </li></ol><ul><li>border-radius:50%.方角变成圆角.</li><li>box-shadow:2px,20px,3px,#777.</li><li>border-image:url(),30,30,round.</li></ul><ol><li>transform:旋转，倾斜，平移，拉伸(scale)等变化，没有过渡时间。transition:有过渡动画，从一种style变成另一种style。animation专门做动画，<br>.div {<br> transition-property: width<br> transition-duration:<br> transition-timing-function:linear<br> transition-delay:2s<br>}<br>@keyframes myani {<br> from:<br> to:<br>}<br>.div {<br> animation:myani<br>}</li><li>盒模型可以帮助块级元素的定位和计算面积，简单来说W3C的盒模型包括content、padding、border、margins。<br>the content area’s size can be explicitly defined with the width；<br>The padding area, bounded by the padding edge, extends the content area to include the element’s padding. is determined by the padding-top, padding-right, padding-bottom, padding-left, and shorthand padding properties.<br>The margin area, bounded by the margin edge, extends the border area to include an empty area used to separate the element from its neighbors.is determined by the margin-top, margin-right, margin-bottom, margin-left, and shorthand margin properties. </li><li>自适应宽度三等分布局: display:table-cell;width:10000px.width:0px,margin:0px.</li><li>字体个数一般用偶数<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2></li><li>Status code:200服务器成功返回网页,204No Content无内容,301 重定向,304 资源没有修改，直接从缓存返回资源.503服务不可用.403Forbidden(禁止)服务器拒绝请求。400Bad request.502BadGateway.500Internal-server-error.</li><li>GET,POST,POST has not content length limit and put message in the content body,</li><li>Cookie, localStorage.</li><li>HTTP request, response</li><li>跟缓存相关的HTTP请求头中有三个字段：<strong>Cache-control</strong>、Expires（指定具体过期日期）、Last-Modified（验证资源是否过期）.关于优先级，Cache-Control比Expires可以控制的多一些， 而Cache-Control会重写Expires的规则，Cache-Control是关于浏览器缓存的最重要的设置，因为它覆盖其他设置，比如 Expires 和 Last-Modified。Mainfest可以缓存一个应用，pwa中有Mainfest和Service Worker可以实现缓存.</li><li>HTTP/HTTPs</li></ol><ul><li>Http是超文本传输协议，信息是明文传输；Https是具有安全性的ssl加密传输协议.</li><li>Http和Https使用的是完全不同的连接方式，用的端口也不一样，Http是80，Https是443.</li><li>Http的连接很简单，是无状态的；Https协议是由SSL+Http协议构建的可进行加密传输，身份验证的网络协议，比Http协议安全。</li></ul><ol><li>XSS是什么？跨站脚本攻击，这些可执行的脚本由攻击者提供，最终为用户浏览器加载，不同于大多数攻击，有存储型和反射型，防御方式，编码，过滤，解码.CSRF:跨站请求伪造</li><li>一个列表，假设有100000个数据，分页的原理，就是每次服务器端返回一定数目的数据。</li><li>HTTP响应步骤：(1)客户端连接到Web服务器:一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口(默认为80)建立一个TCP套接字连接(2)发送HTTP请求:通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成(3)服务器接受请求并返回HTTP响应:Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由<strong>状态行、响应头部、空行和响应数据</strong>4部分组成(4)释放TCP连接(5)客户端浏览器解析HTML内容<br>function.prototype.bind/apply/call<br>apply&amp;call return the result of calling the function with the specified this &amp; arguments。func.bind creates new function with this keyword设置成指定值，copy of func with specified this &amp; initial value.<br>var module = {<br>x: 42,<br>getX: function() {<br> return this.x;<br>}<br>}<br>var retrieveX = (module.getX);//提取出来这个函数<br>console.log(retrieveX());//undefined</li></ol><p>修改方法:var retrieveX = ().bind(module);//绑定执行上下文,要绑定的参数<br>没有return这个函数，不构成闭包。<br>bind()<br><strong>call can accept argument lists, apply can only apply function to single array/array like objects,function.apply(null/this keyword,arr),function.call(this,name,price), which are argument lists.bind</strong></p><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li>lifecycle</li><li>reactjs中虚拟dom要这样实现的原因是什么？</li><li>谈谈你对reactjs的理解？为什么项目中选用reactjs？与其他框架的区别？<br>在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。虚拟DOM确保只对页面上改变的部分进行刷新。高效的diff算法O(n)和Batching处理。<br>MVVM 的变化检查是数据层面的，而React的检查是DOM结构层面的。<h2 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h2></li><li>从一个无序，不相等的数组中，选取N个数，使其和为M实现算法</li><li>值传递，因此引用的是自己变量，0-4(增加i作为参数)。下面这样是55555<br>for (var i = 0; i &lt; 5; i++) {<br>(function() {<br> setTimeout(function() {<br>   console.log(i);<br> }, i * 1000);<br>})(i);<br>}</li><li>给一个数组如：[[“a”,”b”,”c”],[“d”,”e”],…..]得到[ad,ae,bd,be,cd,ce]，手写实现的方法？<br>Array.prototype.join(‘ ‘).直接把数组拼接。String.concat(string).<br>function(arr) {<br> let ans = [];<br> var help = function(arr1,arr2){<pre><code>let ans = [];for(let ele1 of arr1) {    for(let ele2 of arr2)    ans.push(ele1.concat(ele2)):}</code></pre> };<br> help.apply(this,arr[1],arr[2]);<br> return ans;<br>}</li><li>setTimeout(,100)是否会100ms后执行，原因是？EventLoop？<br>同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。<br>setTimeout注册的函数fn会交给浏览器的定时器模块来管理，延迟时间到了就将fn加入主进程执行队列，<strong>如果队列前面还有没有执行完的代码，则又需要花一点时间等待才能执行到fn</strong>，所以实际的延迟时间会比设置的长。<br><strong>在各JS环境中，Promise都是最先执行的</strong>，setTimeout(0)、setImmediate requestAnimationFrame顺序不确定。setInterval().</li><li>new完成了什么事，用代码表达</li><li>正则表达式的运用，完成模板函数</li><li>inline-block标签之间的空白块 </li><li>Bom是什么？列举你知道的Bom对象</li><li>是视频面试，面了一个半小时。先是问了比较基础的三列布局，问了居中处理。然后问了项目，框架。我说的react，就问了生命周期。然后问了闭包。手写一个闭包。根据这个手写的闭包开始问各种问题。他把这个你写的代码改了，问你输出。改了好几次。然后问了冒泡，捕获。又让自己写一个parseInt函数。<br>parseInt(str,base) {<br> if(typeof str !==”string”) return NaN;<br> if (radix == null) {<pre><code>radix = 10;</code></pre> } else if(base&gt;36||base &lt; 2) return NaN;<br> let result = 0;<br> for(var i = 0; i &lt; str.length; i++) {<pre><code>var c = str.charCodeAt(i);if(c &gt;= 97) c-=87;else if(c &gt;=65) c-=55;else c-=48;f (c &gt;= radix) {    if (i === 0) {        return NaN;    }    break;}result = (result * radix) + c;</code></pre> }<br> return result;<br>}<br>函数奇数次调用输出1偶数次调用输出2<br>var A = (function A(){<br>var index = 1;<br>function f(){<br>if(index % 2 == 1){<br>console.log(1);<br>}else{<br>console.log(2);<br>}<br>index++;<br>}<br>return f<br>})()<br>DOM事件流：事件捕获阶段、处于目标阶段、事件冒泡阶段.<br>浏览器会从根节点开始由外到内进行事件传播,即点击了子元素,<strong>如果父元素通过事件捕获方式注册了对应的事件的话,会先触发父元素绑定的事件.</strong>与事件捕获恰恰相反,事件冒泡顺序是由内到外进行事件传播,直到根节点.从内到外输出,child-parent-body.用e.stopPropogation()停止传播.事件委托利用事件冒泡.<br>设置true用事件捕获,false冒泡.<br>提交的两种实现(input+type=submit, button+点击事件)<br>点击事件具体js实现及Jquery对应的api. .click(),.mouseover(),.ready().<br>事件流：<br>绑定事件：addEventListner(false,)默认是false事件冒泡，attachEvent(eventName,handler)..onclick=function(){}.React里面用camelCase<br>React的flex的实现原理<br>弹性布局。任何一个容器都可以指定为 Flex 布局。<br>.box{<br>display: flex;////inline-flex;子元素的float、clear和vertical-align属性将失效。<br>align-items:center;//主轴对齐方式，水平对齐<br>justify-content:center;//垂直居中;flex-start/flex-end/baseline<br>flex-direction:决定主轴方向<br>}<br>jQuery API:hide(),parent(),parents(),children(),find查找后代元素,fadeIn,fadeOut,fadeToggle,.animate({property},ms(speed),function),addClass,removeClass,.ready(),.load().<br>解析过程：创建DOM树，解析CSS，CSS和DOM合并成渲染树。<br>当render tree中的一部分(或全部)因为元素的规模尺寸,布局,隐藏等改变而需要重新构建.这就称为回流(reflow).每个页面至少需要一次回流,就是在页面第一次加载的时候.<br>当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color,则就叫称为重绘。改变字体,增加或者移除样式表,内容变化,设置CSS属性值.<strong>回流一定重汇，重汇不一定回流</strong></li></ol><p>在html方面问了：1、重绘和回流的区别2、视图属性3、CSS标准盒子 （box-sizing）4、清除浮动5、两列布局（右侧定宽200px,左边随屏幕自动填充宽度）6、垂直水平居中7、addEventListener()有几个参数，是什么？type,handler(function/implement EventHandler的函数)<br>padding+border+width/height=盒子长宽<br>js问了：1、typeof的类型（举例说属于什么类型），<strong>typeof null=object</strong>，<strong>typeof a=number/function/undefined/boolean</strong><br>判断是否是数组<br>用typeof判断：typeof null/[]/{} === ‘object’.if({}) true;{}==true/false false. <strong>if([]) true</strong><br>ES6:Array.isArray()<br>if(Object.prototype.toString.call(arr)===’[object Array]’)<br>同理判断是否为objectif(Object.prototype.toString.call(arr)) === ‘[object Object]’;<br>判断是否是对象实例，instanceof<br>2、function.prototype.bind/call/apply的用法及区别</p><p>CSS上下左右居中<br>答父元素position:relative 子元素position:absolute margin:auto 方法很多，还可以用flex, table-cell等</p><p>BOM浏览器对象模型<br>对象包括Window,images,layers,links,frames,areas.<br>1、图片预加载<br>window.onload = function() {<br>    setTimeout(function() {<br>        // XHR to request a JS and a CSS<br>        var xhr = new XMLHttpRequest();<br>        xhr.open(‘GET’, ‘<a href="http://domain.tld/preload.js" target="_blank" rel="noopener">http://domain.tld/preload.js</a>‘);<br>        xhr.send(‘’);<br>        xhr = new XMLHttpRequest();<br>        xhr.open(‘GET’, ‘<a href="http://domain.tld/preload.css" target="_blank" rel="noopener">http://domain.tld/preload.css</a>‘);<br>        xhr.send(‘’);<br>        // preload image<br>        new Image().src = “<a href="http://domain.tld/preload.png" target="_blank" rel="noopener">http://domain.tld/preload.png</a>“;<br>    }, 1000);<br>};</p><p>Function.prototype.bind = function(cxt){<br>    var fn = this;<br>    return function() {<br>        fn.apply(cxt,arguments);<br>    }<br>}</p><p>Function.prototype.bind2 = function (context) {<br>    var self = this;<br>    var args = Array.prototype.slice.call(arguments, 1);<br>    var fBound = function () {<br>        var bindArgs = Array.prototype.slice.call(arguments);<br>        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值<br>        return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));<br>    }<br>    fBound.prototype = this.prototype;<br>    return fBound;<br>}<br>4、自己实现一个promise、sleep； 5、用call或者apply实现bind； 6、==与===，===类型不同直接false,函数对象检查是否指向同一对象。undefined与null===false,<strong>undefined==null true</strong>。==同一类型一样，不同类型会做类型转换。null/undefined==[]/{} false</p><p>7.requireJS,怎么解决循环依赖。a依赖b,b依赖a,调用其中之一时会提示undefined。<br>canvas：beginPath closePath 有什么用<br>closePath是关闭路径的API，如果它将当前点与起点进行连线，形成一个封闭图形。</p><p>在函数中，传参实际传的是值，所以每次都传的是i的值；值传递就能避免闭包。<br>this.name = b.name;<br>console.log(a());  //‘bbb’。使a返回b的name</p><p>(function (){<br>    var i = 9;<br>    funcs<a href="">2</a>;<br>})因为在立即执行函数里var i =9;此时i是局部变量，不会影响闭包中i的引用不会访问到立即执行函数中的i，所以就是5；去掉立即执行函数后，var i = 9;此时的i是全局变量，所以就覆盖了原来的i，所以输出为9.</p><p>Responsive Web Design - The Viewport<br>The viewport is the user’s visible area of a web page.</p><meta name="viewport" content="width=device-width,initial-scale=1.0"><p>1、构造继承<br>2、原型继承<br>3、实例继承<br>4、拷贝继承<br>列出JavaScript的继承实现方式，并使用一种你喜欢的方式实现如下继承<br>原型链继承，children = new Parent();<br>为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例(sub1,sub2)的属性覆盖掉，也存在内存浪费。<br>Children.prototype.helloword = “”;<br>function Child() {<br>    Parent.call(this,username);<br>    //Parent.apply(this,new Array(username));<br>}<br><strong>多个标签页通信主要是利用了localStorage的增删改事件监听</strong><br>function sendMsg(text) {<br>    window.localStorage.setItem(‘msg’,text);<br>}<br>window.addEventListener(‘storage’, function (evt) {<br>    if(evt.key===’msg’)<br>       console.log(evt.newValue);<br>});<br><strong>冒泡排序</strong><br>for (i = 0; i &lt; len; i++) {<br>for (j = 0; j &lt; len-i-1; j++) {<br>    }<br>}<br>等高布局：left:top:0;bottom:0;absolute实现等高。<br>水平居中：<br>1.{<br>    width:200px;<br>    margin:0,auto;//左右全设置成auto,要有固定宽度值<br>}<br>2.{<br>    width:800px;<br>    position:absolute;<br>    margin-left:-400px;<br>    left:50%;<br>}<br>垂直居中：<br>1.高度不固定{<br>    padding-top:==padding-bottom<br>}<br>2.加一个空标签：<div id="floater"></div><br>                <div id="content"></div>#floater{<br>                    float:left;<br>                    height:50%;/<em>相对于父元素高度的50%</em>/<br>                    margin-bottom: -120px;/<em>值大小为居中元素高度的一半（240px/2）</em>/<br>                }</p><pre><code>#content {    clear:both;/*清除浮动*/    height: 240px;    position: relative;}</code></pre><p>3.垂直水平居中：.wrap{<br>    position:absolute;<br>    left:50%;<br>    top:50%;<br>    width:800px;<br>    height:800px;<br>    margin-left:-400px;<br>    margin-top:-400px;         //不知道宽度高度可以用transform:translate(-50%,-50%)<br>} parent:position:relative<br>垂直居中<br>parentElement {<br>    display:flex;/<em>Flex布局</em>/<br>    display: -webkit-flex; /<em> Safari </em>/<br>    align-items:center;/<em>指定垂直居中</em>/<br>    justify-content:center;<br>}</p><p>如何获取一个元素到浏览器边缘的距离？<br>offset: 获取匹配元素在当前视口的相对偏移<br>position: 获取匹配元素相对父元素的偏移<br>scrollTop: 获取匹配元素相对滚动条顶部的偏移<br>scrollLeft: 获取匹配元素相对滚动条左侧的偏移<br>$.trim()是啥，移除开头结尾的空白。然后让我现场写代码实现一个。然后问我$(document).ready() 与window.onload的区别，写代码实现一个$(document).ready()。<br><strong>ready会比onload先执行，绘制完DOM树就开始执行,DOM一旦ready就开始执行绑定的handler.ready能同时编写多个.</strong><br>return (text || “”).replace(/^\s+|\s+$/g, “”)<br>//^匹配输入的开始<br>http并发请求资源数<br>对每一个host限制个数2、4或8.Firefox 3.6.8和chrome 5.0的并发连接数都为6。<br>css雪碧图可以优化http请求数，减少请求数,具体如何减少请求数目。<br><strong>怎样实现一个可以根据浏览器动态宽高（边长）变化的正方形？</strong><br>.placeholder {<br>  width: 100%;<br>  height: 100vw;<br>}<br>.placeholder {<br>  width: 100%;<br>  padding-bottom: 100%;<br>  height:0;<br>}<br>给一个无序列表里面的每个li元素添加事件监听器，我显然知道挖了一个坑呀，然后被我机智地绕过去了。写完之后问我，如果现在要给这个列表再添加两个子元素，这个事件监听要怎么加，然后我说，那就用事件代理吧，就是给父组件绑定事件嘛。还问了我一个简单的算法题，就是判断一个字符串中出现次数最多的那个字符。</p><p><script type="text/javascript"><br>//给父元素添加监听器<br>document.getElementById(“parent-list”).addEventListener//默认冒泡<br>   (“click”,function(e) {<br>    // e.target是被点击的元素!<br>    // 如果被点击的是li元素<br>  console.log(e.target);<br>    if(e.target &amp;&amp; e.target.nodeName == “LI”) {<br>        // 找到目标，输出ID!<br>        console.log(“current click li, id :”+e.target.id);<br>    }<br>});<br></script><br>var str = ‘我爱北京天安门，天安门上太阳升’;<br>var freqs = {}; // 用来记录所有的字符的出现频次<br>var mostFreqChar = ‘’; //用来记录最大频次的字符<br>for (var i = 0; i &lt; str.length; i++) {<br>    var char = str[i];<br>    if (!freqs[char]) {<br>        freqs[char] = 0;<br>    }<br>    freqs[char] ++;<br>    if (mostFreqChar == ‘’ || freqs[char] &gt; freqs[mostFreqChar]) {<br>        mostFreqChar = char;<br>    }<br>}<br>console.log(freqs);<br>console.log(mostFreqChar);<br>//if(undefined/null) 都不会输出<br>块级元素：address - 地址<br>blockquote - 块引用<br>center - 居中对齐块<br>dir - 目录列表<br>div - 常用块级，也是css layout的主要标签<br>dl - 定义列表<br>fieldset - form控制组<br>form - 交互表单<br>h1 - 大标题<br>h2 - 副标题<br>h3 - 3级标题<br>h4 - 4级标题<br>h5 - 5级标题<br>h6 - 6级标题<br>ol,ul<br>行内：abbr,em,strong,input,br,span,img,input</p><p>z-index<br>function foo () { var a = 1 function bar () { console.log(a) } return bar }<br>var baz = foo();<br>baz() // 1</p><p>for (var i = 1; i &lt;= 5; i++) { setTimeout(function timer () { console.log(i) }, i <em> 1000) }<br>访问的是i的全局变量，已经变成6了。<br>for (var i = 1; i &lt;= 5; i++) { (function (j) { setTimeout(function timer () { console.log(j) }, j </em> 1000) })(i) }</p><p>let声明的变量只在自己的代码块内有效，外部引用不到。<br>同一作用域不能重复声明。不存在变量提升（先使用后声明）。<br>console.log(a);//undefined<br>var a = 0;<br>加块级作用于就能显示0</p><p>var a = [];<br>for (var i = 0; i &lt; 10; i++) {<br>  a[i] = function () {<br>    console.log(i);<br>  };<br>}<br>a<a href="">6</a>; // 10全局的i。let则返回6</p><p>for (let i = 0; i &lt; 3; i++) {<br>  let i = ‘abc’;<br>  console.log(i);//abcabcabc<br>}</p><p>主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。</p><p>HTML5 现在已经不是 SGML 的子集,主要是关于图像,位置,存储,多任务等功能的增加。绘画canvas;用于媒介回放的video和audio元素;<br>本地离线存储localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除;cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭.<strong>存储在本地客户端</strong>，在http请求之间传递.<br>自然样式标签、语义样式标签.首选自然样式标签</p><p>访问对象里面的属性的规则（原型链）：<br>先在对象自身寻找，找不到去原型找，原型找不到去原型的原型上去找，直到找到Object.prototype为止。如果Object.prototype也没有则报错。<br><strong>CSS不可继承的样式：border padding margin width height</strong></p><p><strong>block         块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</strong><br>none          缺省值。象行内元素类型一样显示。<br><strong>inline        行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</strong><br><strong>inline-block  默认宽度为内容宽度，可以设置宽高，同行显示。</strong><br>list-item     象块类型元素一样显示，并添加样式列表标记。<br>table         此元素会作为块级表格来显示。<br>inherit       规定应该从父元素继承 display 属性的值。<br>absolute<br>生成绝对定位的元素，相对于值不为static的第一个父元素进行定位。<br>fixed （老IE不支持）<br>生成绝对定位的元素，相对于浏览器窗口进行定位。<br>relative<br>生成相对定位的元素，相对于其正常位置进行定位。<br>浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</p><p>style标签写在body后与body前有什么区别？<br>写在head标签中利于浏览器逐步渲染（resources downloading-&gt;CSSOM+DOM-&gt;RenderTree(composite)-&gt;Layout-&gt;paint）。写在body标签后由于浏览器以逐行方式对html文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染</p><p>SSR:server sends ready to be rendered HTML。有利于SEO，打开速度比本地渲染快。<br>renderToString,renderToStaticMarkup这是 React 服务器端渲染的基础<br>server-side rendering,nodemon,route<br>数组的随机排序<br>var arr = [1,2,3,4,5,6,7,8,9,10];<br>function randSort2(arr){<br>    var mixedArray = [];<br>    while(arr.length &gt; 0){<br>        var randomIndex = parseInt(Math.random()*arr.length);<br>        mixedArray.push(arr[randomIndex]);<br>        arr.splice(randomIndex, 1);<br>    }<br>    return mixedArray;<br>}</p><p>this总是指向函数的直接调用者；在事件中，this指向触发这个事件的对象；如果有new关键字，this指向new出来的那个对象.</p><p><strong>闭包是指有权访问另一个函数作用域中变量和形参的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数</strong>，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</p><p><strong>New干了什么</strong><br>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。<br>2、属性和方法被加入到 this 引用的对象中。<br>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p><p><strong>js延迟加载的方式有哪些？</strong><br>defer=”defer”和async、动态创建DOM方式（用得最多）、按需异步载入js<br>var js = document.createElement(“script”);<br>js.type = “text/javascript”;<br>js.src = “”;<br>document.getElementsByTagName(“head”).appendChild(js);<br>什么都不实用同步加载，在浏览器继续解析页面之前，立即读取并执行脚本<br><strong>创建script，插入到DOM中，加载完毕后callBack</strong></p><p><strong>document.write只能重绘整个页面;element.innerHTML可以重绘页面的一部分</strong></p><p><strong>slice不改变原数组，splice改变原数组。</strong><br>继承Dog.prototype = new Animal();<br>实例化:var doge = new Animal();</p><p>jQuery怎样转换JSON字符串$(“”).stringifyArray(array)<br>$.fn.stringifyArray = function(array) {<br>　　return JSON.stringify(array)<br>}</p><p>$.fn.parseArray = function(array) {<br>　　return JSON.parse(array)<br>}<br>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p><p>判断是不是原生js<br>this === window ? ‘browser’ : ‘node’;</p><p>var a = 6;<br>setTimeout(function () {<br>    alert(a);<br>    var a = 666;<br>}, 1000);<br>a = 66;  输出undefined，变量提升,声明提升到函数开头，但是没有赋值，拆成了两句话</p><p>var a = 6;<br>setTimeout(function () {<br>    alert(a);<br>    a = 666;<br>}, 1000);<br>a = 66;//66</p><p>The <i> tag should represent a range of text with a different semantic meaning whose typical typographic representation is italicized. This means a browser will typically still display its contents in italic type, but is,by definition, no longer required to.</i></p><p>jQuery 的队列是如何实现的？队列可以用在哪些地方？</p><p>jQuery .trigger(type,function params).fire所有匹配类型的事件<br>react-router路由系统的实现原理？<br>React中如何解决第三方类库的问题?</p><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?<br>先发生捕获事件，后发生冒泡事件<br>路由交给浏览器处理就算是;单页应用<br>axios,redux-promise</p><p>*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，<br>因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。<br>此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，<br>因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p><p>*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。</p><p>XSS:攻击者在网页中嵌入客户端脚本(例如JavaScript)。<br>CSRF:跨站请求伪造,通过伪装来自受信任用户的请求来利用受信任的站点。</p><p>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）:<br>而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；<br>详细版：<br>    1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;<br>    2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;<br>    3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;<br>    4、进行HTTP协议会话，客户端发送报头(请求报头);<br>    5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;<br>    6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;<br>    7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;<br>    8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;<br>    9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;<br>    10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</p><p>简洁版：<br>    浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；<br>    服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS等）;<br>    浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）;<br>    载入解析到的资源文件，渲染页面，完成。</p><p>fetch和$().ajax()区别：1.return of fetch won’t reject on HTTP error, only reject when network failure or anything prevented request from completing.<br>2.by default, doesn’t send&amp; receive cookies, if needed sessions need to set init options.</p><p>400,404,403forbidden,401unauthorized<br>500,502badgateway<br>结构化标准语言主要包括XHTML和XML，表现标准语言主要包括CSS，行为标准主要包括对象模型（如W3C DOM）、ECMAScript等。<br>W3C万维网联盟，指定XML,XHTML,CSS等标准。<br>doctype决定浏览器如何解析文档。说明HTML/XHTML是什么版本</p><p>global attributes:class,id,hidden,lang,style,title,contextmenu,dir,itemid,itemscope.</p><p>SVG 是一种使用XML描述2D图形的语言,支持事件处理器,不依赖分辨率。Canvas通过 JavaScript 来绘制2D图形。Canvas是逐像素进行渲染的。</p><p>圆形可点击区域<br>//第二种 使用CSS border-radius</p><p><div id="red" class="click-area"></div></p><p>#red{<br> cursor:pointer;<br> background:red;<br> width:100px;<br> height:100px;<br> border-radius:50%;<br>} </p><p>CSS Sprites是一种网页图片应用处理方式，就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位。减少HTTP请求。</p><p>display:none空间没了，visibility:hidden占据的空间仍然保留。<br>link和@import的差别<br>老祖宗的差别。link属于XHTML标签，而@import完全是CSS提供的一种方式。import不是DOM可以控制的。link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。<br>FOUC文档样式闪烁，IE里面head里没有标签导致没加载。</p><p>CSS2.1中三种定位方式：<br>普通流(Normal Flow)、浮动(Floats)和绝对定位(Absolute Positioning),下面分别对这三种布局简略说明一下。<br>然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。主要是为了文字环绕图片效果。在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定</p><p>BFC:1. BFC会阻止外边距折叠2. BFC可以包含浮动的元素3. BFC可以阻止元素被浮动元素覆盖<br>meta常用标签：name,content,viewport,charset:声明编码,http-equiv.</p><p>CSS样式优先级：最高的是内联<div style="">.然后id-&gt;class-&gt;标签伪选择器</div></p><p>png无损数据，jpg多次上传下载会逐渐失真</p><p>写一个x<em>y</em>z<br>function mul (x) {<br>    return function (y) { // anonymous function<br>        return function (z) { // anonymous function<br>            return x <em> y </em> z;<br>        };<br>    };<br>}</p><p>var salary = “1000$”;</p><p>(function () {<br>    console.log(“Original salary was “ + salary);//undefined,变量提升</p><pre><code>var salary = &quot;5000$&quot;;console.log(&quot;My New Salary &quot; + salary);</code></pre><p>})();<br>var声明的变量优先提升到头部,函数表达式声明也会提升到头部，再进行函数赋值</p><p>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。因此变量提升先在本块内进行。</p><p>异步加载JS脚本：动态创建元素，createElement(“script”);<br>script.src = “A.js”;<br>document.getElementsByTagName(‘head’)[0].appendChild(script);//塞进页面<br>HTML5:async;defer通用,async新特性</p><p>设计模式：单例，工厂，<br>内置对象:NaN,Date,Math,Obejct,eval,parseInt,parseFloat.<br>parseInt(“546”, 2);   // 除了“0、1”外，其它数字都不是有效二进制数字<br>typeof NaN = number</p><p><strong>会话跟踪的方式：URL重写，URL末尾添加数据标识对话；Cookie</strong><br>eval(String)如果没有返回值返回undefined.</p><p>XML重量级，自我设计，W3C推荐标准。</p><p>1、写一个通用的事件侦听器函数<br>2、如何判断一个对象是否为数组<br>3、冒泡排序<br>4、快速排序<br>5、编写一个方法 求一个字符串的字节长度<br>中文占2字节，判断中文或替换<br>export default function qsort(arr) {<br>    if(arr.length === 0 ) return [];<br>    else {<br>        let [pivot, …rest] = arr;<br>        return [<br>            …qsort(arr.filter(ele=&gt;ele &lt;= pivot)),<br>            pivot,<br>            …qsort(arr.filter(ele=&gt;ele &gt;= pivot))<br>        ]<br>    }<br>}<br>export default function bubble(arr) {<br>    var temp;<br>    for(var i = 0; i &lt; arr.length; i++) {<br>        for(var j = 0; j &lt; arr.length-i-1;j++) {<br>            if(arr[j]&gt;arr[j+1])<br>            temp = arr[j];<br>            arr[j] = arr[j+1];<br>            arr[j+1] = temp;<br>        }<br>    }<br>}</p><p>var EventUtil = {<br>    //根据情况分别使用dom2 || IE || dom0方式 来添加事件<br>    addHandler: function(element,type,handler) {<br>        if(element.addEventListener) {<br>            element.addEventListener(type,handler,false);<br>        } else if(element.attachEvent) {<br>            element.attachEvent(“on” + type,handler);<br>        } else {<br>            element[“on” + type] = handler;<br>        }<br>    },</p><pre><code>//根据情况分别获取DOM或者IE中的事件对象，事件目标，阻止事件的默认行为getEvent: function(event) {    return event ? event: window.event;},getTarget: function(event) {    return event.target || event.srcElement;},preventDefault: function(event) {    if(event.preventDefault) {        event.preventDefault();    } else {        event.returnValue = false;    }}//根据情况分别使用dom2 || IE || dom0方式 来删除事件removeHandler: function(element,type,handler){    if(element.removeHandler) {        element.removeEventListener(type,handler,false);    } else if(element.detachEvent) {        element.detachEvent(&quot;on&quot; + type,handler);    } else {        element[&quot;on&quot; + type] = null;    }}//根据情况分别取消DOM或者IE中事件冒泡stopPropagation: function(event) {    if (event.stopPropagation) {        event.stopPropagation();    } else {        event.cancelBubble = true;    }}</code></pre><p>}</p><p>var btn = document.getElementById(“myBtn”),<br>    handler = function () {<br>        alert(“Clicked”);<br>    };</p><p>EventUtil.addHandler(btn,”click”,handler);<br>EventUtil.removeHandler(btn,”click”,handler);<br>GET指定了资源在服务器上的位置，而POST没有<br>XHTML元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素</p><p>var foo = (function() {<br>    var t;<br>    return function() {<br>        if (t) return t;<br>        t = new Date();<br>        return t;<br>    }<br>})();<br>函数返回首次调用的Date对象</p><p>常见布局：<br>float+margin<br>左浮动，右浮动，margin-left/right=left/right的宽度。DOM文档先写两侧蓝，再写主栏。<br>position+margin<br>.left,.right{<br>    position:absolute;<br>    top:0;<br>    width:200px;<br>}.left{left:0;} .right{right:0;}<br>.main{<br>    margin:0,200px;<br>}<br>流体布局</p><p>圣杯布局<br>main必须优先书写，left,right<br>三者都设置浮动,main width:100%,left+right设置相对布局.<strong>都设置margin-left</strong><br>.main {<br>    float: left;<br>    width: 100%;<br>}<br>.sub {<br>    float: left;<br>    width: 190px;<br>    margin-left: -100%;     //左边栏<br>    position: relative;<br>    left: -190px;<br>}<br>.extra {<br>    float: left;<br>    width: 230px;<br>    margin-left: -230px;<br>    position: relative;<br>    right: -230px;  //自身宽度<br>}</p><p>#bd {<br>    padding: 0 230px 0 190px;<br>}</p><p>双飞翼布局,main用margin.圣杯则用padding。<br>用div-wrapper包含div,left+right.<br>.main-wrapper{<br>    width:100%;<br>    float:left;<br>}<br>.left{<br>    float:left;<br>    width:100px;<br>    margin-left:-100%;<br>}<br>.right{<br>    float:left;<br>    width:200px;<br>    margin-left:-200px;<br>}<br>.main{<br>    margin:0,200px,0,100px;<br>}</p><p>事件委托的原理是<strong>事件冒泡</strong>。<br>捕获阶段，目标阶段，冒泡阶段。DOM事件流同时支持两种事件。<br>阻止冒泡：stopPropogation();阻止捕获：preventDefault().</p><p>工厂模式：解决重复实例化</p><p>src放在页面最后加载，防止堵塞。</p><p>combineReducers from redux;<br>export default combineReducers(form,postReducer);<br>applyMiddleware(promise,rootReducers)<br>必须写default.<br>function(state={},action)<br>switch(action.type) {<br>    case FETCH_POSTS:<br>}</p><p>redux-promise provides a promise as middleware and only return when it is resolved. You can use redux-promise in combination with redux-actions.<br>axios make http requests from nodejs,保护XSRF/CSRF</p><p>reducer actions:function deletePost. Component里面<br>mapStateToProps(state) {<br>    return {posts:state.post};//props自身属性<br>}<br>mapActionToProps(dispatch) {<br>    bindActionCreators({fetchPost:fetchPost},dispatch);<br>}<br>目的是为了变成props在View视图中进行触发，obSubmit={this.formSubmit.bind(this)}<br>connect(mapStateToProps,mapActionToProps)(Conponent);<br>componentDidMount()内部进行获取数据改变State等操作.<br>React-router:<provider store="{createStoreWithReducers(reducer)}"></provider></p><p><browserrouter><switch><route></route></switch><br>state是只读的，用触发action修改state.reducer接受新的action把当前state返回新的state.<br>bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。<br>Redux 应用只有一个单一的 store。拆分逻辑通过拆分reducer。<br>维持应用的 state；<br>提供 getState() 方法获取 state；<br>提供 dispatch(action) 方法更新 state；<br>通过 subscribe(listener) 注册监听器;<br>通过 subscribe(listener) 返回的函数注销监听器。<br>严格的单向数据流是 Redux 架构的设计核心。</browserrouter></p><p><strong>展示组件和容器组件</strong>相分离<br>React Rarely have their own state (when they do, it’s UI state rather than data).<br>需要传递的state很深，传递给多层子组件，考虑使用容器来从store直接获取状态。</p><p>在这类框架中，middleware 是指可以被嵌入在框架接收请求到产生响应过程之中的代码。可以被链式组合，使用多个第三方middleware。<strong>redux-middleware提供的是位于 action 被发起之后，到达 reducer 之前的扩展点。</strong><br>使用dev-server开发。 browserHistory移除URL中的#<br>devServer: {<br>  historyApiFallback: true,<br>}</p><p>hot reload(热加载) 就是每次修改某个 js 文件后，页面局部更新。通常来说，当我们修改了代码刷新页面，那应用里的所有状态就都没有了。这对于开发一个单页应用来说是非常痛苦的，因为需要重新跑一遍流程。如果有模块热加载，当你修改了代码，你的代码会直接修改，页面并不会刷新，所以状态也会被保留。</p><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><ul><li><strong>dirname:当前文件所在路径。</strong>filename:当前文件路径名。</li><li><code>app.use(&#39;/user/:id&#39;, function (req, res, next) {console.log(&#39;Request Type:&#39;, req.method);next();});</code>在指定路径上使用中间件，对req/res对象进行更改，结束请求和响应循环。</li><li>后台也有API和MySQL通信。<code>npm install mysql --save</code>. <a href="http://expressjs.com/en/guide/database-integration.html#mysql" target="_blank" rel="noopener">Connection config</a></li><li>Use template files as View.(不使用React).类似JSP,直接获取要显示的内容。典型例子：Jade,ejs,pug.Jade has been updated to Pug.<code>app.set(&#39;views&#39;, &#39;./views&#39;)</code> to set the view source dir.<code>app.set(&#39;view engine&#39;, &#39;pug&#39;)</code>.When you make a request to the home page, the index.pug file will be rendered as HTML.<br>var connection = mysql.createConnection({});<br>connection.connect();<br>connection.query(‘’,function(){});<br>connection.end();<br>isSorted<br>function isSorted(arr) {<br>const limit = arr.length - 1;<br>return arr.every((<em>, i) =&gt; (i &lt; limit ? arr[i] &lt;= arr[i + 1] : true));<br>}<br>intersection of 2 array<br>arr1.filter((n)=&gt;arr2.includes(n));</em>.intersection(arr1,arr2);<br>bind solves problem of context, bind(function, {name:whw});</li></ul><p><strong>apply takes an array of arguments; call takes a column-list of arguments.</strong>功能基本一样</p><p>每次调用then，你都在创建一个新的Promise对象。then就像一个锁链一样，将前后的两个Promise对象连接起来。<br>Promise.prototype.then = function(resFn, rejFn) {<br>  var pP = this;<br>  return new Promise((res, rej) =&gt; thenHandler(res, rej, resFn, rejFn, pP))<br>}</p><p>垂直水平居中复习<br>{<br>    top:50%;<br>    left:50%;<br>    position:absolute;<br>    margin-top:-xx;-height/2<br>    margin-left:-xx;-width/2<br>}<br>{<br>    position:absolute;<br>    top:50%;<br>    left:50%;<br>    transform:translate(-50%,-50%);<br>}</p><p>三等分布局<br>1..child{<br>    float:left;<br>    width:33.3%;<br>}<br>2..child{<br>    display:inline-block;////<br>    width:33.3%;<br>}</p><p>清除浮动:父元素overflow:auto<br>下一个标签:clear:both;</p><p>一般核心区域自适应，侧栏固定.左右两列固定，中间自适应宽度<br>浮动+分别向左右两边浮动.先写侧栏后写main.</p><p>#left,</p><p>#right {<br>float: left;<br>width: 220px;<br>height: 200px;<br>background: blue;<br>}</p><p>#right {<br>float: right;<br>}</p><p>#main {<br>margin: 0 230px;<br>background: red;<br>height: 200px;<br>}<br>///////<br>左右absoulte position, left,right:0;main:margin</p><p>使用margin负值：margin-right:-4px;<br>font-size:///移除空格代码<br>消除inline-block的空格站位问题。</p><p>左右带有侧栏，中间自适应，左右分别向左右两边浮动。main:margin-left/margin-right<br><strong>padding/margin百分比是相对于父级宽度还是自身的宽度,父容器宽度</strong><br><strong>height,top,bottom相对于父容器高度</strong><br>let暂时性死区:let.const区块开始就构成封闭作用域，不能先使用后声明。reference error.</p><p>控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。<br>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。</p><p>function qsort(arr) {<br>    let [pivot,…rest] = arr;<br>    if(arr.length==0) return [];<br>    return [<br>        …qsort(arr.filter((ele)=&gt;ele<pivot)), pivot,="" ...qsort(arr.filter((ele)="">ele&gt;pivot);<br>    ]<br>}</pivot)),></p><p>function(left,right){<br>    var tmp=[];<br>    while (left.length &amp;&amp; right.length) {<br>    if (left[0] &lt; right[0])<br>      tmp.push(left.shift());<br>    else<br>      tmp.push(right.shift());<br>    }<br>  return tmp.concat(left, right);<br>}</p><p>function mergeSort(a) {<br>  if (a.length === 1)<br>    return a;</p><p>  var mid = ~~(a.length / 2)<br>    , left = a.slice(0, mid)<br>    , right = a.slice(mid);</p><p>  return merge(mergeSort(left), mergeSort(right));<br>}</p><p>继承的几种方法：<br>1.构造继承：<br>　　function Animal() {<br>　　　　this.species = “动物”;<br>}<br>function Cat() {<br>    Animal.call(this,specifies);///Animal.apply(this, arguments);<br>    this.name = name;<br>　　this.color = color;<br>}<br>2.原型继承<br><strong>Cat.prototype = new Animal();</strong>核心语句<br><strong>Cat.prototype.constructor = Cat;//必须手动修改构造函数</strong></p><p>//Cat.prototype = Animal.prototype;<br>//Cat.prototype.constructor = Cat;<br>3.拷贝继承<br>var c = Animal.prototype; var p = Animal.prototype;<br>for..=;</p><p>二者皆为异步加载模块。<br>Commonjs适合服务端 require<br>AMD:先定义所有依赖，然后在加载完成后的回调函数中执行：<br>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，<br>function merge(left,right) {<br>    var emp=[];<br>    while(left.length&amp;&amp;right.length) {<br>        if(left[0]&gt;right[0])<br>        emp.unshift(right[0]);<br>        else emp.unshift(left[0]);<br>    }<br>    return emp.concat(left,right);<br>}<br>fucntion mergesort(arr) {<br>    if(arr.length &lt;=1)return arr;<br>    var mid = arr.length/2;<br>    var left = arr.slice(0,mid);<br>    var right = arr.slice(mid);<br>    return merge(mergesort(left),mergesort(right))<br>}</p><p>如果display为none，那么position和float都不起作用，这种情况下元素不产生框<br>否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整。<br>否则，如果float不是none，框是浮动的，display根据下表进行调整<br>否则，如果元素是根元素，display根据下表进行调整<br>其他情况下display的值为指定值<br>总结起来：绝对定位、浮动、根元素都需要调整display</p><p>display:inline-block 什么时候不会显示间隙？(携程)<br>移除空格<br>使用margin负值<br>使用font-size:0<br>letter-spacing<br>word-spacing</p><p>document.getElementById(“ul”).addEventListner(“click”,function(){<br>    if(ul.length &lt;0) return;<br>    if(event.target.Nodename ===”li”)<br>    console.log(“edf”+target.innerHTML);<br>},false);</p><p>函数的变量对象：保存所有包含的参数，内部函数，和变量数据。<br>function foo (arg) {<br>    var variable = ’我是变量‘;<br>    function innerFoo () {<br>         alert(“我是彭湖湾”)<br>    }<br>}<br>foo(‘我是参数’);<br>ExecutionContext = {<br>    variableObject: {<br>      variable：’我是变量‘<br>      innerFoo： [对函数声明innerFoo的引用]<br>      arg: ‘我是参数’<br>    },<br>    this: thisValue,<br>    Scope: [ // Scope chain<br>      // 所有变量对象的列表     ]<br>};<br>innerFoo的作用域链包含所有的变量对象。foo的包含自己和外部。</p><p><strong>可能会使用到多层嵌套的闭包，这种用法，叫做“柯里化”。而闭包柯里化有两大作用：参数累加和延迟调用</strong>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。<br>var foo1 = foo(‘我’);<br>var foo2 = foo1(‘叫’);<br>foo2(‘彭湖湾’); // 打印 我叫彭湖湾</p><p>function createArray() {<br>   var arr = new Array();<br>   for (var i = 0; i &lt; 10; i++) {<br>      arr[i] = function () {<br>         return i;<br>      }<br>    }<br>    return arr;<br>}<br>var funcs = createArray();<br>for (var i = 0; i &lt; funcs.length; i++) {<br>     document.write(funcs<a href="">i</a> + “<br>“);<br>}</p><ol><li><p>这几个函数都保留着对同一个外部函数的变量对象的引用</p></li><li><p>因为闭包函数“延迟调用”的特性，而关键变量值i的获取是在闭包函数调用（f也即uncs<a href="">i</a>）的时候才从外部函数的变量对象中获取，而这个时候，外部函数早就完成for循环使 i =10了 !!!</p></li></ol><p>.main {<br>    position:absolute;<br>    width:200px;<br>    height:300px;<br>    top:50%;<br>    left:50%;<br>    margin-top:-150px;<br>    margin-left:-100px;////transform:translate(-50%,-50%);<br>}box-sizing:border-box;</p><p>var a = 1;<br>a.a = 2;<br>console.log(a.a);//undefined</p><p>//split返回字符数组。str.split(seprator).reverse().join(seprator);<br>var arr=msg.split(“-“);   //split(“-“)以-为分隔符截取字符串，返回数组<br>for(var i=1;i&lt;arr.length;i++){<br>    arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1);<br>}<br>msg=arr.join(“”);          //join()加入什么，连接数组元素，返回字符串<br>return msg;<br>//范围内随机整数<br>function getRandomInt(min, max) {<br>    return Math.floor(Math.random() * (max - min + 1)) + min;<br>}<br>数组去重，新数组indexOf().<br>var arr = [2,4,2,2,5,6,7,8,9,9,9];<br>    function unique(arr){<br>        var arr1 = [];<br>        for (var i = 0;i &lt; arr.length;i ++){<br>            if(arr1.indexOf(arr[i]) == -1){<br>                arr1.push(arr[i]);<br>            }<br>        }<br>        return arr1;<br>    } </p><p>function unique(array) {<br>    var res = array.filter(function(item, index, array){<br>        return array.indexOf(item) === index;<br>    })<br>    return res;<br>}</p><p>Function.prototype.bind = function(ctx) {<br>var fn = this;<br>return function() {<br>    fn.apply(ctx, arguments);<br>};<br>};</p><p>for (var i = 0; i &lt; 5; i++) {<br>  setTimeout((function(i) {<br>    console.log(i);<br>  })(i), i * 1000);<br>}立即输出0-4</p><p>箭头函数没有this,不能new,没有原型属性prototypes</p><p>异步编程的四种方式：<br>1.callback<br>2.事件监听:任务的执行不取决于代码的顺序，而取决于某个事件是否发生。<code>f1.on(&#39;done&#39;, f2);</code>,<code>function f1(){setTimeout(function () {// f1的任务代码 f1.trigger(&#39;done&#39;);}, 1000);}</code>.<br>3.发布/订阅:<code>jQuery.subscribe(&quot;done&quot;, f2);</code>.<br>4.Promise:(1)顺序promise,链式调用。(2)Promise类有一个all方法，其接受一个promise数组:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([promise1,promise2,...,promise10]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>new Promise(function(resolve,reject){<br>    setTimeout(function(){},1000);<br>});<br>Promise.all([promise1,promise2,promise3]);<br>只有promise数组中的promise全部兑现，才会调用then方法。使用Promise.all，我们可以并发性的进行网络请求，并在所有请求返回后在集中进行数据展示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发请求章节数据，一次性按顺序展示章节</span></span><br><span class="line"><span class="built_in">Promise</span>.all(chapterStrs.map(getChapter)).then(<span class="function"><span class="keyword">function</span>(<span class="params">chapters</span>)</span>&#123;</span><br><span class="line">    chapters.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">chapter</span>)</span>&#123;</span><br><span class="line">        addToPage(chapter);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>并发处理多个AJAX请求,jQuery:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = $.Deferred();  </span><br><span class="line"><span class="keyword">var</span> d2 = $.Deferred();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    d1.resolve( <span class="string">"Fish"</span> );  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">    d2.resolve( <span class="string">"Pizza"</span> );  </span><br><span class="line">&#125;  </span><br><span class="line">**$.when(deferred)提供一种方法执行一个或多个对象的回调函数。**</span><br><span class="line">等待所有延迟函数解析完返回.then/.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">$.when( d1, d2 ).done(<span class="function"><span class="keyword">function</span> (<span class="params"> v1, v2 </span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log( v1 + v2 + <span class="string">'已完成'</span>);  </span><br><span class="line">&#125;);  </span><br></pre></td></tr></table></figure></p><p>函数节流，不希望函数太频繁的触发：resize,scroll,mousemove,keydown/keyup.在 JavaScript 中，debounce 函数所做的事情就是，强制一个函数在某个连续时间段内只执行一次，哪怕它本来会被调用多次。<br>debounce实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定时器，用来 setTimeout</span></span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line">  <span class="comment">// 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保存函数调用时的上下文和参数，传递给 fn</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(context);<span class="comment">//打印this就是打印当前这个函数</span></span><br><span class="line">    <span class="comment">// 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn</span></span><br><span class="line">    clearTimeout(timer)</span><br><span class="line">    <span class="comment">// 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），</span></span><br><span class="line">    <span class="comment">// 再过 delay 毫秒就执行 fn</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实例：在用户“停止”输入一小段时间以后，再发送请求。那么 debounce 就派上用场了：<br>$(‘input’).on(‘keyup’, debounce(function(e) {<br>    // 发送 ajax 请求<br>}, 300))</p><p>固定函数执行的速率，即所谓的“节流”。正常情况下，mousemove 的监听函数可能会每 20ms（假设）执行一次，如果设置 200ms 的“节流”，那么它就会每 200ms 执行一次。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, threshhold</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录上次执行的时间</span></span><br><span class="line">  <span class="keyword">var</span> last</span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line">  <span class="comment">// 默认间隔为 250ms</span></span><br><span class="line">  threshhold || (threshhold = <span class="number">250</span>)</span><br><span class="line">  <span class="comment">// 返回的函数，每过threshhold毫秒就执行一次 fn 函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保存函数调用时的上下文和参数，传递给 fn</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="comment">// 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃</span></span><br><span class="line">    <span class="comment">// 执行 fn，并重新计时</span></span><br><span class="line">    <span class="keyword">if</span> (last &amp;&amp; now &lt; last + threshhold) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">        <span class="comment">// 保证在当前时间区间结束后，再执行一次 fn</span></span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">      &#125;, threshhold)</span><br><span class="line">    <span class="comment">// 在时间区间的最开始和到达指定间隔的时候执行一次 fn</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      last = now</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>debounce&amp;&amp;throttle区别<br>The <strong>setInterval()</strong> method of the WindowOrWorkerGlobalScope mixin repeatedly calls a function or executes a code snippet, with a fixed time delay between each call. It returns an interval ID which uniquely identifies the interval, so you can remove it later by calling clearInterval()./clearTimeout()</p><p>loadash可以直接替换underscore，并获得性能上的提升。<br><em>.debounce/</em>.throttle()都是返回一个特定执行的函数。</p><p>_.before(n,func)call n次才invoke func.</p><p>_.spread(func)return function much like apply.<br>spread operator, myfunc(…args);多个参数参数传递、多个变量(用于解构赋值)。</p><p>function test(a, b, c) { }<br>var args = [0, 1, 2];<br>test.apply(null, args);<br>//test(…args);<br>字面变量合并：var arr2=[…arr1,’d’,’e’];<br>解构：let [pivot,…rest] = arr;//只能用在最后</p><p>二面还是会手写代码，实现一些函数<br>大概过了5分钟，二面面试官就上线了，开始也是自我介绍，还是一面的那几句。然后问了和一面基本一样的问题，html5的新特性，CSS3的新特性，追问我localStorage、sessionStorage和session的区别（这次加了个session）。然后问我addeventListener第三个参数是干嘛的，好像答错了，平时确实没怎么用到过。</p><p><strong>session存在于服务期端，cookie存在于客户端。session会在一定时间内保存在服务器上。webStorage仅仅在本地客户端存储。sessionStorage不在不同窗口共享；cookie&amp;localStorage在同源窗口共享。sessionId每次客户发起请求会带上sessioonID,没有的话服务端分配。</strong><br>Cookie隔离：<br>把js，css，图片等静态资源放在非主域名下，这样在请求这些资源的时候就不会带上主域名的cookie。从而降低传输成本和服务端的压力</p><p>先是问我对jquery熟不熟，我说没怎么用过，平时用的比较多的是vue和react这些框架。但是，面试官仿佛对jquery有一种执念，还是继续问我jquery的问题，很崩溃，jquery我真是几乎没用过，先问我知不知道$.trim()是啥，然后让我现场写代码实现一个。然后问我$(document).ready() 与window.onload的区别，接着让我写代码实现一个$(document).ready() ，这几个问题应该都没答好，然后面试官也懒得问了，就让我实现一个快速排序，然后说一说时间和空间复杂度，然后再就问了几个基础题，就让我等消息了。<br>str.replace(‘/^\s+|\s+$/‘);<br>//Next greater element<br>//从后面开始的数字应该依次递增，找到第一个递减的。记录位置，从末尾开始找第一个比这个数字大的，交换数字，逆向排序后面的元素。</p><p>this.咋回事<br>实现一个<strong>$(document).ready()</strong><br>Array.prototype.apply(this,arguments);</p><p>flex属性都代表什么意思</p><p>事件函数：发生某一事件会触发回调：$(document).ready(function(){<br>    $().click(function(){….}).加载对象，DOM解析之后<br>}). focus, mouseover,<br>chaining,事件依次发生执行。<br>.attr(“width”,”180px”),.attr()获取属性值,.text(),.val(value)设置或返回匹配元素的值。返回表单字段值。.remove()删除子元素、选中元素且删除其下面的所有包含事件。</p><p>load()方法从服务器加载数据，并把返回的数据放入被选元素中。<br><strong>$().load(URL,data,callback)</strong>回调函数。<br>arguments.callee contains the currently executing function.<br>function (fn) {<br>    if($(document).addEventListner) {<br>        $(document).addEventListner(“DOMContentLoaded”,function(){<br>            $().removeEventListner(“DOMContentLoaded”,arguments,callee,false);<br>            fn();<br>        },false)<br>    }<br>}</p><p>const animal = {<br>name:[“es6”,”c++”,”java”],<br>love:[“lxj”,”mama”,”java”],</p><p>fun:function(){<br>let fn = this;//增加这一句function才能辨别到外部对象的this是什么<br>setTimeout(function(){<br>    console.log(fn.name[2]);<br>    console.log(fn.love[1]);<br>},200);<br>}<br>}<br>animal.fun();</p><p>或者用立即执行函数bind(this).<br>const animal = {<br>name:[“es6”,”c++”,”java”],<br>love:[“lxj”,”mama”,”java”],</p><p>fun:function(){<br>setTimeout((function(){<br>    console.log(this.name[2]);<br>    console.log(this.love[1]);<br>}).bind(this),200);<br>}<br>}<br>animal.fun();<br>///////////////////////////////////////////////<br>rem工作原理<br>熟悉node和element对象<br>原生的DOM操作<br>断点调试法nodejs<br>严格模式（ES5）<br><strong>em作为字体单位为父元素大小，作为其他属性为相对自身大小。</strong><br>rem相对于非根元素相对于根元素字体大小。vm/vw视口高度宽度</p><p>文档本身是文档节点<br>所有HTML元素是元素节点<br>所有HTML属性是属性节点<br>HTML元素内的文本是文本节点<br>注释是注释节点<br>element.scrollTop上边缘与视图间距/scrollLeft与左边缘的距离<br>element.scrollWidth宽度、scrollHeight</p><p>文字垂直居中：vertical-align:center只适用于有这个属性的标签，<td><caption>.<div><span>是没有的。设置line-height:==height的高度。<br>多行内容居中，<strong>且容器高度可变</strong>，也很简单，给出一致的padding-bottom和 padding-top 就行：<br>.middle-demo-2{<br>padding-top: 24px;<br>padding-bottom: 24px;<br>}</span></div></caption></td></p><p><strong>box-sizing:border-box;保证border和padding不改变元素自身大小。</strong><br>padding-bottom和width设置为百分比来保证元素自适应宽高</p><p>DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。<br>document.createElement(“div”);//并未添加到html文档中;<br>document.querySelector(“.class”);//选中第一个<br>document.getElementByClassName(“class”);<br>document.querySelectorAll(“class”);<br>ele.appendChild(e1);//////jQuery append,prepend,after(在被选元素之后插入内容),before(在被选元素之前插入内容)<br>ele.removeChild(e2);<br>ele.replaceChild(el1, el2);//替换子元素<br>var c = el.getAttribute(‘class’);<br>el.setAttribute(‘class’, ‘highlight’);</p><p>jQuery appendTo()添加到文档结尾.<br>$().html()写入标签内部内容</p><p>DOM元素的innerHTML, outerHTML, innerText, outerText属性的区别也经常被面试官问到。<div>内部html，整个HTML，内部text.</div></p><p>Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型，JS中所有节点都继承自Node类型，都共享着相同的基本属性和方法。    element nodetype==1.nodeName为元素标签名，tagName也是返回标签名，返回大写形式(DIV). document nodeValue为null,nodeName为#document。</p><p>nodejs调试方式<br>npm install -g node-inspector<br>node-inspector –web-port 8080 –debug-port 5859<br>8080为调试页面窗口。<br><a href="http://localhost:8080/debug?port=5858打开页面" target="_blank" rel="noopener">http://localhost:8080/debug?port=5858打开页面</a><br>V8 Inspector Integration可以让DevTools直接连接 Node.js的Debugger进行调试。<br>node –inspect app.js</p><p>apply可以不传入参数：则为null 或 undefined.<br>类数组对象变成数组：[…arguments];//Array.prototype.slice.apply(null,arguments);</p><p><strong>只要不是float和绝对定位方式布局的，都在普通流里面。</strong><br>元素如果被定位了，那么它的top,left,bottom,right值就会生效，能设置定位的属性是relative,absolute和fixed</p><p>立即执行函数<br>// 下面2个括弧()都会立即执行</p><p>(function () { /<em> code </em>/ } ()); // 推荐使用这个<br>(function () { /<em> code </em>/ })(); // 但是这个也是可以用的</p><p>事件的Event对象<br>当一个事件被触发的时候，会创建一个事件对象（Event Object），这个对象里面包含了一些有用的属性或者方法。事件对象会作为第一个参数，传递给我们的回调函数。function(e) {console.log(e.target.value);}<br>event.type()事件名称;event.target要触发的目标节点;event.currentTarget正在处理事件的元素。</p><p>Flex元素是可以让你的布局根据浏览器的大小变化进行自动伸缩,自动适应空间。<br>align-items:交叉轴上对齐/justify-content:水平方向对齐</p><p>浏览器环境中this是全局window.<br>var foo = 2;<br>this.foo==window.foo.<br>函数正常调用时指向的是全局作用域，function foo(){this.x=”sad”;}foo();<br>使用new进行调用创建新的上下文，对象实例，console.log(foo().x)//sad;this.x=外部x.<br>用new创建的对象开始时会共用一个原型。<br>在原型上创建属性，一个做改变都会受影响，在函数内部创建不会受影响。<br>Thing.prototype.foo = “dsa”;new Thing(),thing1.foo=”das”.thing2.foo=也会受到改变。<br>如果原型链中某个地方对变量赋值，就进行了覆盖。</p><p>function Thing() {<br>}<br>Thing.prototype.foo = “bar”;<br>Thing.prototype.logFoo = function () {<br>    var info = “attempting to log this.foo:”;<br>   // var fn=this;<br>    function doIt() {<br>        console.log(info, this.foo);//这样打出来是UNdefined<br>    }<br>    doIt();<br>}</p><p>var thing = new Thing();<br>thing.logFoo();  //logs “attempting to log this.foo: undefined”</p><p>this指代的是window全局对象、访问函数外部对象是通过闭包。因此要bind(this).<br>使用变量保存this在函数做参数传递时不奏效。exter(fun);</p><p>对于对象，直接的函数方法可以访问到this属性；包含的函数还是访问不到。<br>var obj = {<br>    foo: “bar”,<br>    logFoo: function () {<br>        console.log(this.foo);<br>    }<br>};<br>obj.logFoo(); //logs “bar”</p><p>DOM中的回调this指向绑定元素。<div>sada</div>.除非自己bind(this)<br>无法重写this。<br>.on/off(eventName)取消绑定。<br>.on({<br>    mouseover:function(){},<br>    mouseleave:function(){},<br>    click:function(){}<br>})<br>.on(click,function(){});</p><p>event.currentTarget==this,事件委托的话是绑定的元素、target是真正触发的元素。<br>$.Deferred()解决如何处理耗时操作，返回一个可供链式调回调函数队列。它彻底改变了如何在jQuery中使用ajax。相当于异步回调操作<br>$.ajax(“index.html”).done(function(){alert(“dsa”)}).fail(function(){fail})可以添加多个回调函数.done().done(function(){});<br>ajax返回一个deferred对象；$.when(havefun()).done(…).fail(…).<br>when函数传递进去的必须是一个deferred对象，可以new Deferred();dtn.resolve().<br>$.data(id,key,value)<br>jQuery.noConflict();库冲突原理</p><p>Normal Flow<br>Containing Block<br>Margin Collapse<br>BFC  <strong>块格式化上下文</strong><br>Baseline<br>Writing Mode<br>unicode-bidi</p><p>模板引擎</p><p>理解方法的 arguments 变量，包括如何使用它来通过 arguments.length 重载函数，以及通过 arguments.callee 来进行递归调用，需要注意使用这个特性有一定的危险性，因为 ECMAScript 5 的 Strict 模式不支持此功能，但 jQuery 和 Dojo 都用到了它。<br>高级闭包比如 self-memoizing 函数，partially applied 函数，以及最可爱的 (function(){})() 调用。<br>函数以及 HTML prototype，prototype chain，以及如何使用基本的javascript对象和函数（比如 Array）来简化代码。<br>对象类型以及 instanceof 的使用<br>正则表达式和表达式编译<br>With 语句以及为什么不要使用它们<br>with的本意是减少键盘输入。比如<br>　　obj.a = obj.b;<br>　　obj.c = obj.d;<br>可以简写成<br>　　with(obj) {<br>　　　　a = b;<br>　　　　c = d;<br>　　}<br>但是，在实际运行时，解释器会首先判断obj.b和obj.d是否存在，如果不存在的话，再判断全局变量b和d是否存在。这样就导致了低效率，而且可能会导致意外，因此最好不要使用with语句。</p><p>eval性能和安全性的问题<br>尽量使用函数表达式声明函数，这样遵循先声明后使用的规范。</p><p>如何高效的操作 DOM（添加，删除以及更新），还有如何通过使用 document fragments 这样的工具来最小化浏览器的 re-flows。<br>跨浏览器的事件处理，绑定，反绑定，冒泡，以及<strong>如何取得期望的回调上下文</strong>。在一次，现成的框架也可以很好的处理这些事情，但是你应该对 IE 浏览器和 W3C 标准浏览器之间的不同有所了解。<br>正则表达式选取 DOM 节点<br>$代表jQuery函数.<br>$.fn=$.prototype<br>jQuery.fn.extend({})添加成员函数.<br>$(‘[name=NameOfSelectedTag] :selected’)</p><p>//jQuery中使用，等待DOM加载完毕后就执行<br>$(document).ready(fucntion(){…})</p><p>//jQuery中使用，<strong>等待页面全部加载完毕后才执行</strong>（图片音频视频等全部加载完毕后才执行）<br>$(window).load(function(){ …})</p><p>//纯js中使用，等待页面全部加载完毕后才执行（图片音频视频等全部加载完毕后才执行）<br>window.onload = function(){…}</p><p><strong>detach()和remove()方法的区别是什么?</strong><br>detach仅仅从DOM中删除，不删除绑定的事件和数据，还能恢复;remove全部删除。<br>如何利用jQuery来向一个元素中添加和移除CSS类?<br>addClass,removeClass().</p><p>.each chain选中的元素：$().each(function(element){}),对每个选中的元素进行操作。<br><strong>$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法</strong></p><p>使用CDN的优势<br>除了报错节省服务器带宽以及更快的下载速度这许多的好处之外, 最重要的是，如果浏览器已经从同一个CDN下载了相同的jQuery版本, 那么它就不会再去下载它一次.<br>原生js更高效，直接调用了JS引擎。<br>$().attr(name,value)设置或返回属性值,string格式”color”:”blue”<br>DOM tree+CSSOM===render tree</p><p>什么是JS的函数防抖？</p><p>jQuery一个对象可以绑定多个事件，$().on({})<br>“click”:function(){},””:function(){}.<br>$(“div”).trigger(“click”,data);传递数据进来</p><p>this总是指向函数的直接调用者（而非间接调用者）；<br>如果有new关键字，this指向new出来的那个对象；<br>在事件中，this指向触发这个事件的对象</p><p>Cookie隔离：如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量，所以不如隔离开。<br>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节，提高了webserver的http请求的解析速度。</p><p>jquery.extend 为jquery类添加类方法，可以理解为添加静态方法<br>源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数<br>使用：<br>jquery.extend扩展，需要通过jquery类来调用，静态对象，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。</p><p>for<li><br>Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。</li></p><p>(function(){<br>  var a = b = 3;<br>})();</p><p>console.log(“a defined? “ + (typeof a !== ‘undefined’));<br>console.log(“b defined? “ + (typeof b !== ‘undefined’));</p><p>false,true<br>b=3;<br>var a=b;<br>b被定义成全局变量</p><p>var myObject = {<br>    foo: “bar”,<br>    func: function() {<br>        var self = this;<br>        console.log(“outer func:  this.foo = “ + this.foo);<br>        console.log(“outer func:  self.foo = “ + self.foo);<br>        (function() {<br>            console.log(“inner func:  this.foo = “ + this.foo);<br>            console.log(“inner func:  self.foo = “ + self.foo);<br>        }());<br>    }<br>};<br>myObject.func();</p><p>bar.bar.undefined.bar;直接对象的成员能访问到.</p><p>立即执行函数：jQuery中避免变量污染.</p><p>js里面return 后面不能跟换行，否则会加分号，变undefined。<br>function foo2()<br>{<br>  return<br>  {<br>      bar: “hello”<br>  };<br>}</p><p>判断数字是否是整数<br>function isInteger(x) {<br>    return parseInt(x, 10) === x;<br>}<br>Number.isInteger(x);</p><p>判断参数的个数，arguments.length<br>function sum() {<br>  var fir = arguments[0];<br>  if(arguments.length === 2) {<br>    return arguments[0] + arguments[1]<br>  } else {<br>    return function(sec) {<br>       return fir + sec;<br>    }<br>  }<br>}</p><p>slice(),使用-index返回数组里最后几个元素组成的数组.(-1)返回最后一个元素.<br>reverse会改变数组本身，并返回数组的引用.</p><p>if(undefined)—&gt;false<br>加定时器防止堆栈溢出<br>if([])console.log()会显示输出.区别于[]==false<br>[]==[] false/////[]===[] false<br>if({})//会显示输出<br>[]==false true; {}==false false {}==true false<br>‘0’==false true  Boolean(‘0’) true</p><p>var hero = {<br>    _name: ‘John Doe’,<br>    getSecretIdentity: function (){<br>        return this._name;<br>    }<br>};<br>var stoleSecretIdentity = hero.getSecretIdentity;<br>console.log(stoleSecretIdentity());<br>console.log(hero.getSecretIdentity());//undefined<br>需要绑定上下文</p><p><strong>给所有children增加callback</strong><br>函数接受指定的参数////回调函数<br>function Traverse(p_element,p_callback) {<br>    p_callback(p_element);<br>    var list = p_element.children;<br>    for (var i = 0; i &lt; list.length; i++) {<br>        Traverse(list[i],p_callback);  // recursive call<br>    }<br>}</p><p>function Foo() {<br>    getName = function () { alert(1); }<br>    return this;<br>}<br>Foo.getName = function () { alert(2); }//静态属性<br>Foo.prototype.getName = function () { alert(3); }<br>var getName = function () { alert(4); }//函数变量表达式<br>function getName () { alert(5); }//函数声明<br>/<em> 写出输出 </em>/<br>Foo.getName();   //2,访问静态属性<br>getName();      //4,,,,,,函数声明和函数表达式会进行变量提升拆分成两部分<br>//////////var getName;function getName;//下面的函数表达式又一次进行覆盖<br>Foo().getName();  //1,调用Foo(),进行了函数赋值,当前作用育没有，向上寻找，将全局的覆盖掉。<br>getName();//1，相当于window.getName()<br>new Foo.getName();//2，.的运算及高，出现2、、内部属性<br>new Foo().getName();//3  ()运算及高，先执行new Foo()<br>new new Foo().getName();//3</p><p><strong>slice/concat浅拷贝，对象只拷贝指针，互相影响</strong><br>JSON.stringify(JSON.parse(arr))深拷贝</p><p>数组去重，filter保留index是他本身的<br>function unique (arr) {<br>    var res = arr.filter(function (item, index, array) {<br>        return array.indexOf(item) === index;<br>    })<br>    return res;<br>}<br><strong>数组扁平化，全部展开。_.flatten</strong><br>var arr = [1, [2, [3, 4]]];<br>function flatten(arr) {<br>    while (arr.some(item =&gt; Array.isArray(item))) {<br>        arr = [].concat(…arr);<br>    }<br>    return arr;<br>}</p><p>Array.isArray()调用传参.</p><p>函数防抖：debounce,尽管事件发生多少次，一定在ns之后触发函数。如果又触发就以此作为新的时间节点。<br>debounce.cancel = function(){clearTimeout(timer);timer=null;}</p><p>组合函数嵌套，函数作为参数：<br>compose<br>function compose() {<br>    var args = arguments;<br>    var start = args.length - 1;<br>    return function() {<br>        var i = start;<br>        var result = args[start].apply(this, arguments);<br>        while (i–) result = args[i].call(this, result);<br>        return result;<br>    };<br>};</p><p>$.extend(obj,obj1,obj2)将两个更多对象合并到目标对象里面.<br>数组乱序<br>function shuffle(a) {<br>    var j, x, i;<br>    for (i = a.length; i; i–) {<br>        j = Math.floor(Math.random() * i);<br>        x = a[i - 1];<br>        a[i - 1] = a[j];<br>        a[j] = x;<br>    }<br>    return a;<br>}</p><p>MVVM,View,Viewmodel,model.Model和Viewmodel之间双向通信。<br>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p><p>deferred.done(callback) callback function to be called.</p><h2 id="Design-pattern"><a href="#Design-pattern" class="headerlink" title="Design pattern"></a>Design pattern</h2><p>工厂模式定义创建对象的接口，但是让子类决定实例化哪个类。工厂方法将类的实例化延迟到子类。<br>jQuery中的$()其实就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的jQuery对象。<br>当需要根据不同参数产生不同实例，这些实例都有相同的行为，这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量。工厂模式有利于消除对象间的耦合，提供更大的灵活性。</p><p>Lazy Load其实是对图片的一种延迟加载技术，直到用户滚动图片出现在用户可视范围时才把它加载出来。它与图片预加载技术完全相反，却都是为了提高用户体验而设计。</p><p>$().load(url,data,callback)从服务器获取数据<br>$().ready(function(){});只能用于当前文档；无需选择器//$(document).ready</p><p>jQuery ready函数实现<br>function ready(fn){<br>if(document.addEventListener) {      //标准浏览器<br>    document.addEventListener(‘DOMContentLoaded’,function() {<br>        //注销时间，避免反复触发<br>        document.removeEventListener(‘DOMContentLoaded’,arguments.callee,false);<br>        fn();       //执行函数<br>    },false);<br>    }<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;front-end-SEO&quot;&gt;&lt;a href=&quot;#front-end-SEO&quot; class=&quot;headerlink&quot; title=&quot;front-end SEO&quot;&gt;&lt;/a&gt;front-end SEO&lt;/h2&gt;&lt;p&gt;Search engine Optimization，具体方法包括：&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-binary-search-practice-4</title>
    <link href="http://yoursite.com/2018/01/17/leetcode-binary-search-practice-4.html"/>
    <id>http://yoursite.com/2018/01/17/leetcode-binary-search-practice-4.html</id>
    <published>2018-01-17T23:36:01.000Z</published>
    <updated>2018-01-18T03:16:03.825Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a>209. Minimum Size Subarray Sum</h3><p>Can use 2 pointers with <code>O(n)</code> complexity. Notice that when end read the end of array should continue to move the start pointer.<br><a id="more"></a></p><h3 id="392-Is-subsequence"><a href="#392-Is-subsequence" class="headerlink" title="392. Is subsequence"></a>392. Is subsequence</h3><ol><li>Use DP. very simple 1D DP.Notice that should check whether pattern string has already reached the end.</li><li>Use preprocessing &amp; binary search for a lot of pattern string. eg: record all positions of matched string, then use position keep tracking its first appearing position.</li><li>Can use a Trie to record the current all pattern string. Now comes another string, find longest prefix in the trie and starts from here to match with the base string.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;209-Minimum-Size-Subarray-Sum&quot;&gt;&lt;a href=&quot;#209-Minimum-Size-Subarray-Sum&quot; class=&quot;headerlink&quot; title=&quot;209. Minimum Size Subarray Sum&quot;&gt;&lt;/a&gt;209. Minimum Size Subarray Sum&lt;/h3&gt;&lt;p&gt;Can use 2 pointers with &lt;code&gt;O(n)&lt;/code&gt; complexity. Notice that when end read the end of array should continue to move the start pointer.&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="binary search" scheme="http://yoursite.com/tags/binary-search/"/>
    
      <category term="two pointers" scheme="http://yoursite.com/tags/two-pointers/"/>
    
  </entry>
  
  <entry>
    <title>leetcode binary search practice 3</title>
    <link href="http://yoursite.com/2018/01/15/leetcode-binary-search-practice-3.html"/>
    <id>http://yoursite.com/2018/01/15/leetcode-binary-search-practice-3.html</id>
    <published>2018-01-16T02:48:55.000Z</published>
    <updated>2018-01-17T23:36:18.321Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a>162. Find Peak Element</h3><p>There may exsists many peak elements in array, only need to return 1 index. If it’s a sorted array, answer will be first or last element.<br>random select 1 element, if not peak element, if left neighbors larger than it, peak will exists in left part, otherwise right part. Notice the edge case where length == 2, then simply comes to start/end.</p><h3 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34. Search for a Range"></a>34. Search for a Range</h3><p>Simple binary search to find initial value, then search for the range. My solution is a little complex to loop to boundary, worst case go to <code>O(n)</code>. actually, <code>start = find(target), end = find(target + 1) -1</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h3 id=&quot;162-Find-Peak-Element&quot;&gt;&lt;a href=&quot;#162-Find-Peak-Element&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="binary search" scheme="http://yoursite.com/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>莫愁前路无知己</title>
    <link href="http://yoursite.com/2018/01/15/%E8%8E%AB%E6%84%81%E5%89%8D%E8%B7%AF%E6%97%A0%E7%9F%A5%E5%B7%B1.html"/>
    <id>http://yoursite.com/2018/01/15/莫愁前路无知己.html</id>
    <published>2018-01-16T01:02:40.000Z</published>
    <updated>2018-01-16T01:24:33.780Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="莫愁前路无知己"><a href="#莫愁前路无知己" class="headerlink" title="莫愁前路无知己"></a>莫愁前路无知己</h3><p>大雪下了一夜都没停，今天去湖边转了一圈整个湖水都冻住了，也算是奇景了。几对情侣走在浩渺茫茫的湖面上，应该是生命中很难忘的体验吧。<br>话别诗最有名的一句就是<br><blockquote><p>莫愁前路无知己，天下谁人不识君。</p></blockquote><br>语句中饱含着宽慰和豁达。然而相比送别我还是更喜欢重逢吧，即使是<br><blockquote><p>深知身在情长在，前尘不共彩云飞</p></blockquote><br>这种伤感的风格。</p><h3 id="家门口的雪人"><a href="#家门口的雪人" class="headerlink" title="家门口的雪人"></a>家门口的雪人</h3><p><img src="/assets/blogimgs/1.15snowman.jpg" width="80%" height="60%" alt="snowman"></p><h3 id="Lake-Mendota"><a href="#Lake-Mendota" class="headerlink" title="Lake Mendota"></a>Lake Mendota</h3><p><img src="/assets/blogimgs/1.15mendota2.jpg" width="80%" height="60%" alt="snowman"></p><h3 id="音乐分享"><a href="#音乐分享" class="headerlink" title="音乐分享"></a>音乐分享</h3><p>今天分享银临的<strong>《不老梦》</strong>。新专辑《蚍蜉渡海》也出了好久了，然而寄到家的时候我已经在美国了。。只能等回家听了。最喜欢这首歌的文案，一个很凄美、令人动容的爱情故事。也许这些故事也上演在我们身边吧。贴上银临自己的创作灵感。<br><a id="more"></a><br><blockquote><p>终南有坟，名不老。客奇之，问何故，言乃淮南翁主媗冢。<br>元光二年上巳，媗于渭水之滨遇振翊将军韩衿，悦之。明年，河水决濮阳，上发卒十万救决河，使衿督。媗送别，诉心意。衿以其年尚幼，婉拒之。<br>后三年，衿戍定襄，媗托尺素，书：妾已及笄。<br>复三年，媗随姊陵探长安，约结上左右。每逢衿，且喜且怯。<br>又三年，媗疾，久不愈。衿随大将军青击匈奴，媗恐不复见，追大军十余里，终力竭。呛血白衣，形销骨立。<br>元狩元年，淮南衡山事发，陵媗皆下狱。衿欲面之，叩未央宫，额血流地，上弗允。媗殒，衿亲葬于终南。<br>后长安有歌曰：茔茔蔓草，岁岁不老；风雨如晦，死生为谁。<br>终南有坟，名不老。</p></blockquote><br><blockquote><p>清明说：这首歌主题是“求不得”，但并不是不敢追寻才不得，而是努力了、尝试了，依然不可得。因为时代，因为环境，因为外界的桎梏和内心的枷锁。因为人在天命面前，总是渺小得可怜。纵使如此，依然不悔地去爱着，是怎样一种苍凉的勇气？是“知其不可而为之”，“虽千万人吾往矣”。</p></blockquote></p><div class="aplayer" data-id="421137682" data-server="netease" data-type="song"></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;莫愁前路无知己&quot;&gt;&lt;a href=&quot;#莫愁前路无知己&quot; class=&quot;headerlink&quot; title=&quot;莫愁前路无知己&quot;&gt;&lt;/a&gt;莫愁前路无知己&lt;/h3&gt;&lt;p&gt;大雪下了一夜都没停，今天去湖边转了一圈整个湖水都冻住了，也算是奇景了。几对情侣走在浩渺茫茫的湖面上，应该是生命中很难忘的体验吧。&lt;br&gt;话别诗最有名的一句就是&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;莫愁前路无知己，天下谁人不识君。&lt;/p&gt;
&lt;/blockquote&gt;&lt;br&gt;语句中饱含着宽慰和豁达。然而相比送别我还是更喜欢重逢吧，即使是&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;深知身在情长在，前尘不共彩云飞&lt;/p&gt;
&lt;/blockquote&gt;&lt;br&gt;这种伤感的风格。&lt;/p&gt;
&lt;h3 id=&quot;家门口的雪人&quot;&gt;&lt;a href=&quot;#家门口的雪人&quot; class=&quot;headerlink&quot; title=&quot;家门口的雪人&quot;&gt;&lt;/a&gt;家门口的雪人&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/assets/blogimgs/1.15snowman.jpg&quot; width=&quot;80%&quot; height=&quot;60%&quot; alt=&quot;snowman&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Lake-Mendota&quot;&gt;&lt;a href=&quot;#Lake-Mendota&quot; class=&quot;headerlink&quot; title=&quot;Lake Mendota&quot;&gt;&lt;/a&gt;Lake Mendota&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/assets/blogimgs/1.15mendota2.jpg&quot; width=&quot;80%&quot; height=&quot;60%&quot; alt=&quot;snowman&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;音乐分享&quot;&gt;&lt;a href=&quot;#音乐分享&quot; class=&quot;headerlink&quot; title=&quot;音乐分享&quot;&gt;&lt;/a&gt;音乐分享&lt;/h3&gt;&lt;p&gt;今天分享银临的&lt;strong&gt;《不老梦》&lt;/strong&gt;。新专辑《蚍蜉渡海》也出了好久了，然而寄到家的时候我已经在美国了。。只能等回家听了。最喜欢这首歌的文案，一个很凄美、令人动容的爱情故事。也许这些故事也上演在我们身边吧。贴上银临自己的创作灵感。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="音乐" scheme="http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="古风" scheme="http://yoursite.com/tags/%E5%8F%A4%E9%A3%8E/"/>
    
  </entry>
  
  <entry>
    <title>JSP Student-system review</title>
    <link href="http://yoursite.com/2018/01/14/JSP-Student-system-review.html"/>
    <id>http://yoursite.com/2018/01/14/JSP-Student-system-review.html</id>
    <published>2018-01-15T00:50:40.000Z</published>
    <updated>2018-01-15T02:46:42.414Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Project-Review"><a href="#Project-Review" class="headerlink" title="Project Review"></a>Project Review</h2><p>Develop a simple <a href="https://github.com/whw19950510/Studentsystem" target="_blank" rel="noopener">student management system</a> using pure Servlet, MySql and Bootstrap. Basically supports CRUD functionality, ie: create, read, update, delete. Also supports search functionality. Need further improvement on high efficiency sql query, high concurrency and some consideration of loading balance.<br><a id="more"></a></p><h2 id="Understanding-of-MVC-design-patterns"><a href="#Understanding-of-MVC-design-patterns" class="headerlink" title="Understanding of MVC design patterns"></a>Understanding of MVC design patterns</h2><p>Some frenquently used j2ee functions, includes:</p><ul><li>request.getParameter(): get the parameter value in the HTML form(name property).</li><li>request.setAttribute/getAttribute(), used to retrieve value from request(send from 1 page to another).</li><li>dispatcher.forward(request, response): forward the request to some page, be careful with the dispatcher’s constructor should be passed into value of JSP/Servlet, which can cause different effects.<h2 id="Problem-met-in-project"><a href="#Problem-met-in-project" class="headerlink" title="Problem met in project"></a>Problem met in project</h2></li><li>When developing the update functionality, fail to update with no error show up. Try to show the id on the jsp page and found it always come to 0. Finally found that it’s due to not set up corresponding properties and set it to request attribute.</li><li>Have difficulty with the CSS coding to properly layout the button… Waste a lot of time to adjust the button to be aligned with each other. Need further understanding of display: inline/block property, float property and BOX model(making use of margin+padding).</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Project-Review&quot;&gt;&lt;a href=&quot;#Project-Review&quot; class=&quot;headerlink&quot; title=&quot;Project Review&quot;&gt;&lt;/a&gt;Project Review&lt;/h2&gt;&lt;p&gt;Develop a simple &lt;a href=&quot;https://github.com/whw19950510/Studentsystem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;student management system&lt;/a&gt; using pure Servlet, MySql and Bootstrap. Basically supports CRUD functionality, ie: create, read, update, delete. Also supports search functionality. Need further improvement on high efficiency sql query, high concurrency and some consideration of loading balance.&lt;br&gt;
    
    </summary>
    
    
      <category term="Java EE" scheme="http://yoursite.com/tags/Java-EE/"/>
    
      <category term="JSP" scheme="http://yoursite.com/tags/JSP/"/>
    
  </entry>
  
  <entry>
    <title>雪夜</title>
    <link href="http://yoursite.com/2018/01/14/%E9%9B%AA%E5%A4%9C.html"/>
    <id>http://yoursite.com/2018/01/14/雪夜.html</id>
    <published>2018-01-15T00:17:24.000Z</published>
    <updated>2018-01-15T02:50:20.930Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="雪夜"><a href="#雪夜" class="headerlink" title="雪夜"></a>雪夜</h2><p>来之前就在知乎上看到过麦迪逊冬天很长，有的冬天一直持续到来年四五月份，海本们因此都练就了一小时雪中刨车的技能hhh。来了才知道名不虚传，午睡起来又开始洋洋洒洒地下雪。这的雪花像北方的雪，结成块的那种，像棉花糖，街上的雪聚在一起，风一吹像白色的沙一样，很好看。<br><img src="/assets/blogimgs/1.14snow.jpg" width="80%" height="60%" alt="Union South is snowing"></p><h2 id="音乐分享"><a href="#音乐分享" class="headerlink" title="音乐分享"></a>音乐分享</h2><p>静谧的雪夜，最适合思念。今天推荐<strong>《兔子先生》</strong>。开始以为是云泣原唱，后来才知道是洛天依的电子声。没事的时候去B站上翻了下那个<a href="https://www.bilibili.com/video/av2877056/" title="沙画视频" target="_blank" rel="noopener">沙画视频</a>。也是满满的泪点呢。<br>兔子先生大概也是小孩子自己吧。歌词和旋律都很朴素，但可能恰巧因为这种平素让人难以忘怀。<br><blockquote><p>流浪不是一个人的旅途，早点给自己找一个家，让自己的心不再漂泊。总有人会在你身旁，牵住你的手，帮你把那个不懂事的小孩子释放出来，抱住他，也亲吻他，让他舒舒服服躺在怀中，安心听她把兔子先生的故事讲完。</p></blockquote><br>好想听你们弹琴啊，希望五月快一点到来。<br><blockquote><a id="more"></a><p>小孩子问妈妈<br>兔子的家在哪里啊<br>妈妈笑着回答<br>月亮是兔子先生的故乡<br>小孩子问妈妈<br>兔子先生咋不回家<br>妈妈笑着回答<br>流浪是兔子先生的特长<br>小孩子嘟着嘴<br>说兔子先生怎么不听话<br>兔子公公 兔子婆婆<br>会想念他 会担心他<br>小孩小孩轻声说<br>啊兔子先生请你快回家<br>最爱你的爸爸妈妈<br>在那远空 盼望你啊<br>兔子先生笑着说<br>啊小孩小孩我也会想家<br>但渺小的我<br>流浪的步伐<br>还没法停下</p></blockquote></p><div class="aplayer" data-id="34614479" data-server="netease" data-type="song"></div>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;雪夜&quot;&gt;&lt;a href=&quot;#雪夜&quot; class=&quot;headerlink&quot; title=&quot;雪夜&quot;&gt;&lt;/a&gt;雪夜&lt;/h2&gt;&lt;p&gt;来之前就在知乎上看到过麦迪逊冬天很长，有的冬天一直持续到来年四五月份，海本们因此都练就了一小时雪中刨车的技能hhh。来了才知道名不虚传，午睡起来又开始洋洋洒洒地下雪。这的雪花像北方的雪，结成块的那种，像棉花糖，街上的雪聚在一起，风一吹像白色的沙一样，很好看。&lt;br&gt;&lt;img src=&quot;/assets/blogimgs/1.14snow.jpg&quot; width=&quot;80%&quot; height=&quot;60%&quot; alt=&quot;Union South is snowing&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;音乐分享&quot;&gt;&lt;a href=&quot;#音乐分享&quot; class=&quot;headerlink&quot; title=&quot;音乐分享&quot;&gt;&lt;/a&gt;音乐分享&lt;/h2&gt;&lt;p&gt;静谧的雪夜，最适合思念。今天推荐&lt;strong&gt;《兔子先生》&lt;/strong&gt;。开始以为是云泣原唱，后来才知道是洛天依的电子声。没事的时候去B站上翻了下那个&lt;a href=&quot;https://www.bilibili.com/video/av2877056/&quot; title=&quot;沙画视频&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;沙画视频&lt;/a&gt;。也是满满的泪点呢。&lt;br&gt;兔子先生大概也是小孩子自己吧。歌词和旋律都很朴素，但可能恰巧因为这种平素让人难以忘怀。&lt;br&gt;&lt;blockquote&gt;&lt;p&gt;流浪不是一个人的旅途，早点给自己找一个家，让自己的心不再漂泊。总有人会在你身旁，牵住你的手，帮你把那个不懂事的小孩子释放出来，抱住他，也亲吻他，让他舒舒服服躺在怀中，安心听她把兔子先生的故事讲完。&lt;/p&gt;
&lt;/blockquote&gt;&lt;br&gt;好想听你们弹琴啊，希望五月快一点到来。&lt;br&gt;&lt;blockquote&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="音乐" scheme="http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>leetcode binary search practice 2</title>
    <link href="http://yoursite.com/2018/01/14/leetcode-binary-search-practice-2.html"/>
    <id>http://yoursite.com/2018/01/14/leetcode-binary-search-practice-2.html</id>
    <published>2018-01-14T17:19:20.000Z</published>
    <updated>2018-03-05T00:11:48.416Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Binary-search-problems"><a href="#Binary-search-problems" class="headerlink" title="Binary search problems"></a>Binary search problems</h2><p>Today just practice some easy but typical problems, which use both binary search &amp;&amp; 2 pointers. Notice how to pick up pivot.<br><a id="more"></a></p><h3 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69.Sqrt(x)"></a>69.Sqrt(x)</h3><p>Met with this problem in an intrview before and I didn’t notice the type of number at that time…Should use an variable to record the number which is closest to <code>sqrt(x)</code> each time.</p><h3 id="349-167-Two-sum-in-sorted-array"><a href="#349-167-Two-sum-in-sorted-array" class="headerlink" title="349/167.Two sum in sorted array"></a>349/167.Two sum in sorted array</h3><p>Use 2 pointers can be more precise. Notice the condition judgement.</p><h3 id="74-Search-a-2D-matrix"><a href="#74-Search-a-2D-matrix" class="headerlink" title="74.Search a 2D matrix"></a>74.Search a 2D matrix</h3><p>Matrix has property of increasing like a single array. Thus can use binary search directly.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length, col = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = row*col - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) /<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(matrix[mid/col][mid%col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(matrix[mid/col][mid%col] &lt; target) &#123;</span><br><span class="line">    start = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(start == end &amp;&amp; matrix[start/col][start%col] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="240-Search-a-2D-matrix"><a href="#240-Search-a-2D-matrix" class="headerlink" title="240.Search a 2D matrix"></a>240.Search a 2D matrix</h3><p>I only make use of the increasing row property, use the right corner as pivot and search entire row or not, which leads to <code>O(mlog(n))</code> complexity. Better solution is also to use the column increasing property, shrink row/col index by 1 each time, which has <code>O(m+n)</code>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Binary-search-problems&quot;&gt;&lt;a href=&quot;#Binary-search-problems&quot; class=&quot;headerlink&quot; title=&quot;Binary search problems&quot;&gt;&lt;/a&gt;Binary search problems&lt;/h2&gt;&lt;p&gt;Today just practice some easy but typical problems, which use both binary search &amp;amp;&amp;amp; 2 pointers. Notice how to pick up pivot.&lt;br&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="binary search" scheme="http://yoursite.com/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>leetcode binary search practice</title>
    <link href="http://yoursite.com/2018/01/13/leetcode-binary-search-practice.html"/>
    <id>http://yoursite.com/2018/01/13/leetcode-binary-search-practice.html</id>
    <published>2018-01-13T14:23:35.000Z</published>
    <updated>2018-02-08T15:19:08.429Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Binary-search-problems"><a href="#Binary-search-problems" class="headerlink" title="Binary search problems"></a>Binary search problems</h2><p>Typical problems include rotate array. I am not familiar with this kind of problem, especially how to divide them into different situation.<br><a id="more"></a><br>Usually, the end situation written as <code>start &lt; end</code>, so that the final return value can be written as nums[start] to avoid some edge situation. In addition, the mid value calculation should be written as <code>mid = start + (end - start)/2</code> to avoid overflow of number range.</p><h3 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h3><p>Divide the situation into array rotated &amp; not rotated. If <code>nums[start] &lt; nums[end]</code>, the array is not rotated, simply return nums[0]. Then for the rotated situation, there are 2 cases:</p><ul><li><code>nums[mid] &lt; nums[end] &amp;&amp; nums[mid] &lt; nums[start]</code>, minimum is on left side.</li><li><code>nums[mid] &gt; nums[end] &amp;&amp; nums[mid] &gt; nums[start]</code>, minimum is on right side.<br>Can write <strong>end</strong> side check condition, (if use <strong>start</strong> will have decreasing order edge case.)notice that when change value of start &amp; end need to deal with edge case.(when carry with no equal, update, otherwise, keep)</li></ul><h3 id="33-Search-in-rotated-array"><a href="#33-Search-in-rotated-array" class="headerlink" title="33.Search in rotated array"></a>33.Search in rotated array</h3><p>Same as previous problem, use nums[mid] &amp; nums[right] to judge which part is ordered, then judge target lies in which part to get the result.</p><h3 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h3><p>Use idea same as <a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">linkedlist cycle 2</a>. Very tricky to understand array entry since they are all in 1-N range. Just find the entry of the cycle.</p><h3 id="Review-of-find-minimum-in-sorted-array"><a href="#Review-of-find-minimum-in-sorted-array" class="headerlink" title="Review of find minimum in sorted array"></a>Review of find minimum in sorted array</h3><p>Always compare the nums[mid] with nums[end]; When you classify different situations, you need also to consider when the rotated array already become a sorted array, you need to <strong>combine this situation into several another situation</strong>, this is important. Otherwise, answers error when you don’t consider the array shrink process.</p>]]></content>
    
    <summary type="html">
    
      Daily practice of alogorithms. Some tricks in binary search and its variation forms.
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="binary search" scheme="http://yoursite.com/tags/binary-search/"/>
    
  </entry>
  
  <entry>
    <title>冬日随想@麦迪逊</title>
    <link href="http://yoursite.com/2018/01/12/%E5%86%AC%E6%97%A5%E9%9A%8F%E6%83%B3-%E9%BA%A6%E8%BF%AA%E9%80%8A.html"/>
    <id>http://yoursite.com/2018/01/12/冬日随想-麦迪逊.html</id>
    <published>2018-01-13T01:10:20.000Z</published>
    <updated>2018-01-14T05:42:12.299Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="一个人的麦迪逊"><a href="#一个人的麦迪逊" class="headerlink" title="一个人的麦迪逊"></a>一个人的麦迪逊</h2><p>寒假的最后一周啦，人真的是很矛盾的动物，明知道岁月匆忙，还是忍不住它能走的快一点，大概还是因为有点孤独吧。今天最后一个室友也出门去玩了，自己做个饭放个音乐哼个小曲码几行代码，日子倒也自在。刚暖和了两天的麦屯今天又一下子跌到-12C了。不过想想以后回忆起来还是会感谢这段时光吧，和大一时一样专注地学习和做事，麦屯的天空和湖水会永远留在心底的。</p><h5 id="Basecom-Hall雪景"><a href="#Basecom-Hall雪景" class="headerlink" title="Basecom Hall雪景"></a>Basecom Hall雪景</h5><p><img src="/assets/blogimgs/1.12wisc.jpg" width="80%" height="60%" alt="Basecom Hall雪景"></p><h5 id="CS-Department"><a href="#CS-Department" class="headerlink" title="CS Department"></a>CS Department</h5><p><img src="/assets/blogimgs/1.12cs.jpg" width="80%" height="60%" alt="Basecom Hall雪景"></p><h2 id="音乐分享"><a href="#音乐分享" class="headerlink" title="音乐分享"></a>音乐分享</h2><p>不知从什么时候起爱上了网易云音乐这个App。推送很应景，评论留言的朋友们都有各自各样的感人故事，爱情友情亲情个人奋斗，比小说精彩多了hhh，最关键的是它不封海外IP，还一样能听到我最爱的银临、不才、司夏女神们。<br>今天循环了<strong>山外小楼听夜雨</strong>。一条评论写的很好：<br><blockquote><p>有人问我做中国人是什么体验。我告诉他，认得汉字，识得诗词，赏得风月，闻得茶香，入宫商角徵羽，不知是多少辈子修来的福分。</p></blockquote><br>感谢爸妈，从小让我学民乐背诗词，一个人再孤单的时候也能去音乐中找到一点慰藉。听古风大概听的就是这样一种独特的心境吧。<br>歌词里写的像是苏东坡，料峭春风吹酒醒，一蓑烟雨任平生；也可以是欧阳修，月上柳梢头，人约黄昏后；也是柳三变，惟有长江水，无语东流；不忍登高临远，望故乡渺邈，归思难收。听完之后好像站在南京的长江边上了呀！<br><a id="more"></a><br><blockquote><p>数着春去熟透的红豆 无人黄昏后<br>庭前寒冷深秋为谁消瘦<br>月下惟有我的身影投 该与谁厮守<br>酒入喉却解不了愁<br>芙蓉花又栖满了枝头 奈何蝶难留<br>漂泊如江水向东流<br>望断门前隔岸的杨柳 寂寞仍不休<br>我无言让眼泪长流<br>我独酌山外小阁楼 听一夜相思愁<br>醉后让人烦忧 心事难收<br>山外小阁楼 我乘一叶小舟<br>放思念随风漂流</p></blockquote></p><div class="aplayer" data-id="405597568" data-server="netease" data-type="song"></div>]]></content>
    
    <summary type="html">
    
      今日分享音乐《山外小楼听夜雨》
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="音乐" scheme="http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="古风" scheme="http://yoursite.com/tags/%E5%8F%A4%E9%A3%8E/"/>
    
  </entry>
  
  <entry>
    <title>leetcode union find practice</title>
    <link href="http://yoursite.com/2018/01/12/leetcode-practice-process.html"/>
    <id>http://yoursite.com/2018/01/12/leetcode-practice-process.html</id>
    <published>2018-01-12T22:23:19.000Z</published>
    <updated>2018-01-14T04:35:28.354Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="Union-find-problems"><a href="#Union-find-problems" class="headerlink" title="Union find problems"></a>Union find problems</h2><h3 id="261-Graph-Valid-Tree"><a href="#261-Graph-Valid-Tree" class="headerlink" title="261. Graph Valid Tree"></a>261. Graph Valid Tree</h3><p>This is a typical union find problem. Notice that not only do you need to detect the loop, but also need to detect it is a <strong>connected</strong> graph.<br>Notice that when judge whether 2 components is connected &amp;&amp; union 2 components together, always get to <strong><em>the most far</em></strong> parent nodes.<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[p] == p) <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">return</span> find(parent,parent[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(parent,p) == find(parent, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] parent, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index1 = find(parent, p);</span><br><span class="line">        <span class="keyword">int</span> index2 = find(parent, q);</span><br><span class="line">        <span class="keyword">if</span>(index1 != index2) &#123;</span><br><span class="line">            parent[index1] = index2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validTree</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isConnected(parent, edge[<span class="number">0</span>], edge[<span class="number">1</span>]) == <span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            union(parent, edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isConnected(parent, parent[i],parent[<span class="number">0</span>])) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Some problems solved by Union-find can also be solved by DFS. For example, lc200,lc547&amp;&amp;lc130. lc130 uses a small trick, which just set an additional node to represent the node in boundary, which can’t be transformed,then expand them into center part.</p>]]></content>
    
    <summary type="html">
    
      key idea of leetcode problems, learn how to use Union find data structure
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="union find" scheme="http://yoursite.com/tags/union-find/"/>
    
  </entry>
  
  <entry>
    <title>Learn to use maven to manage project</title>
    <link href="http://yoursite.com/2018/01/01/Learn-to-use-maven-to-manage-project.html"/>
    <id>http://yoursite.com/2018/01/01/Learn-to-use-maven-to-manage-project.html</id>
    <published>2018-01-01T06:17:35.000Z</published>
    <updated>2018-01-16T01:24:41.641Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h3 id="Maven-learn-review"><a href="#Maven-learn-review" class="headerlink" title="Maven learn review"></a>Maven learn review</h3><p>Today I spend some free time learning how to use Maven to manage the dependencies and create project’s structure. This posts will continue to be updated.<br><a id="more"></a></p><h4 id="Basic-instructions"><a href="#Basic-instructions" class="headerlink" title="Basic instructions"></a>Basic instructions</h4><ul><li><code>mvn clean compile</code> will generate target folder, which contains the class files generated by dependencies.</li><li><code>mvn clean test</code> will compile and add Junit test module. Need to add junit dependencies to pom.xml first.</li><li><code>mvn clean package</code> will generate jar file of your project.</li><li><code>mvn clean install</code> will generate your project into the local repository and let other projects be able to depend on it.<h4 id="Write-pom-xml"><a href="#Write-pom-xml" class="headerlink" title="Write pom.xml"></a>Write pom.xml</h4>Write groupId as package name, ArtifactId as project name. Then add dependencies to the <code>&lt;dependencies&gt;&lt;/dependencies&gt;</code> block.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Maven-learn-review&quot;&gt;&lt;a href=&quot;#Maven-learn-review&quot; class=&quot;headerlink&quot; title=&quot;Maven learn review&quot;&gt;&lt;/a&gt;Maven learn review&lt;/h3&gt;&lt;p&gt;Today I spend some free time learning how to use Maven to manage the dependencies and create project’s structure. This posts will continue to be updated.&lt;br&gt;
    
    </summary>
    
    
      <category term="Java EE" scheme="http://yoursite.com/tags/Java-EE/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ES6 review</title>
    <link href="http://yoursite.com/2017/05/15/ES6-review.html"/>
    <id>http://yoursite.com/2017/05/15/ES6-review.html</id>
    <published>2017-05-16T02:41:18.000Z</published>
    <updated>2018-03-06T15:30:06.260Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="JS-basic"><a href="#JS-basic" class="headerlink" title="JS basic"></a>JS basic</h2><p>JS is OOScripting language.<br>JS on the client side access the DOM.<br>JS on the server side can communicate with databases.<br><a id="more"></a><br>Using <code>&lt;script type = &quot;text/javascript&quot; src=&quot;./index.js&quot;&gt;&lt;/script&gt;</code> to directly use the JS code.<br>DOM enables dynamically generate HTML code. Eg:document.getElementById().innerHTML() = ‘’.<br>var can start with <code>$</code>,no number,no space. Camelcasing var.<br>var data = [];data.push(0),data.pop();<br>onkeypress/onChange事件</p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h4 id="New-features"><a href="#New-features" class="headerlink" title="New features"></a>New features</h4><p>arrow functions, import, const.<br>let a = 5 === var a = 5;<br>local scope vs global scope. {}.differenciate from closure.{work in its self scope}<br>`` as template string. ${}<br>[10,…a,50];spread operator concatenate.<br>function(…a){}, gathering all parameters into an array.<br>let [name,parent] = a;<br>()=&gt;,no this contained. Annoynous function expression{<br>    function() {};<br>}<br>.map(function)/filter(boolean test). string.repeat(50)/startsWith()/includes(). Safe integer: Number.isSafeInteger(number).<br>module: split code into file based on relevance. export default add; import add from “math.js”/import {multiply} from “math.js”.</p><h4 id="Webpack-amp-Babel"><a href="#Webpack-amp-Babel" class="headerlink" title="Webpack &amp; Babel"></a>Webpack &amp; Babel</h4><p>Using webpack(打包工具) &amp;&amp; Babel to let JS be compatible with the browser. Basically they are transpilier, generate code to olderjs.<strong>webpack bundles multiple modules into one js file</strong>, come with dev-server, update timely.<br>npm install webpack –save-dev.<br>npm install babel-core babel-loader webpack-dev-server babel-preset-es2015 babel-polyfill –save-dev.<br>npm install –save-dev babel-preset-react.<br>webpack.config.js:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    entry: [<span class="string">'babel-polyfill'</span>,<span class="string">'./app/index.js'</span>],</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:__dirname + <span class="string">'/build'</span>,</span><br><span class="line">        filename:<span class="string">'bundle.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">module</span>:&#123;</span><br><span class="line">        loaders:[</span><br><span class="line">            &#123;</span><br><span class="line">                loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">                test:/\js$/,</span><br><span class="line">                exclude:/node_modules/</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        port: <span class="number">3000</span>,</span><br><span class="line">        contentBase:<span class="string">"./build"</span>,</span><br><span class="line">        inline:<span class="keyword">true</span> <span class="comment">// automatically update code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>package.json:<code>script:&quot;build&quot;:&quot;webpack&quot;</code>. add <code>&quot;babel&quot;:{&quot;presets&quot;:[&quot;es2015&quot;] }</code>, <code>&quot;start&quot;: &quot;webpack-dev-server&quot;</code>.</p><h4 id="Classes-in-ES6"><a href="#Classes-in-ES6" class="headerlink" title="Classes in ES6"></a>Classes in ES6</h4><ol><li>relate each other with Inheritence</li><li>Defined with <strong>class</strong> keyword and assign data with <strong>constructor</strong> function.</li><li>Use <strong>extends</strong> keyword to generate child classes. Child classes has all properties of parent classes. Use <strong>super(arg1, arg2)</strong> to use parent properties.</li><li>Static methods in class. Can use all methods in this class using class name.</li><li>Classes &amp; Prototypes. Object-oriented programming:object hold data interact with each other. JS is not, <strong>prototypal inheritence model. Classes are extractions of prototypes. A prototype reveals object’s parent</strong>. All objects has prototypes(Date,array). Prototype chain: top is object.</li><li>class.prototype.func = function(){}; add a new method to the class. prototypes are simply functions. Must use function to generate because ()=&gt; has no this contained.<h4 id="Data-structure-in-ES6"><a href="#Data-structure-in-ES6" class="headerlink" title="Data structure in ES6"></a>Data structure in ES6</h4></li><li>Set(). let a = new Set(can contain arg). a.add() can add all different var. a.has(). for(let element of a.values()){element+=1;}</li><li>Map(). map.size(). key can be anything rather than object’s key can only be string. a.set(key,value)/get(key), a.has(). key can be object/function/string; for(let [key,value] of map.entries()); <h4 id="Closures"><a href="#Closures" class="headerlink" title="Closures"></a>Closures</h4></li><li><strong>Closures refers to functions that remember the environment they are created in and can reference independent variable within this env. Closures combine functions with environment within which we declare that function</strong>. 是函数独有的特性，普通block是可以引用到的。function内部的function/data 外部直接引用不到。</li><li>Enables function factories: function return function. Enable private data, in js can’t do it directly, can emulate this behavior.</li><li>Lexical scoping refers to function use a var to keep tracks of where it can access. <strong>All local var only lasts through the completion of function, but can use closures still access the data</strong>. eg: let fun = ()=&gt;{a=2;let help=()=&gt;{consoloe.log(a);}return help}; let ano = fun;ano() can access a.</li><li>let addSurfix = (x)=&gt;{ const concat = (y)=&gt;{return y+x;} return concat;}. let addness = addSurfix(“ness”)(this will generate a function, concat).let h = addness(“happi), h() shows happiness.<h4 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h4></li><li>break typical run to complete model in normal functions. Generators can pause in the middle and resume later, with <strong>yield(),next()</strong>.  Yield tells function to pause and return current state.</li><li>enable construct control-flow functions and iterators. function* maker(){yield count+=3;} let ano = maker();ano.next().value;建立一个generator的实例。eg:help generate IDs/counter.</li><li>Generator vs iterator, write your own iterator.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayIndex = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; array.length()) &#123;</span><br><span class="line">                <span class="keyword">let</span> next = array[index];</span><br><span class="line">                index +=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = arrayIndex([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(it.next());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterator</span> = (<span class="params">array</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* <span class="built_in">arguments</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> it = iterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">it.next().value;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Asynchronous-programming-amp-Promises"><a href="#Asynchronous-programming-amp-Promises" class="headerlink" title="Asynchronous programming &amp; Promises"></a>Asynchronous programming &amp; Promises</h4><ol><li>Asynchronous programming divert block to event handler. Running on a looped engine, keeps a program running without block.</li><li>Important reason: (1)User interfaces &amp; browser are asynchrounous in nature. function diverted to handler and processed in background. Async enables interation with DB, API.</li><li>Promises handles aync in ES6(before callback). Promises presented in 3 states:<strong>pending, fulfilled, rejected</strong>.</li><li>resolve &amp; reject represents handlers that gives a function to update the state of promise. reject means promise can’t determine a value. <strong>Accessing the promise data as consuming the process.</strong>Use a promise.then() which accepts function gets promise’s return value once it is fulfilled.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">'Resolved a promise'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="params">respose</span>=&gt;</span><span class="built_in">console</span>.log(response))<span class="comment">//Consuming the processed data</span></span><br><span class="line">.catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise doesn't resolved immediately</span></span><br><span class="line"><span class="keyword">new</span> Promsie(setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>resolve(<span class="string">'dsad'</span>),<span class="number">3000</span>).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after promise'</span>);</span><br><span class="line"><span class="comment">// Can still run the code after the promise</span></span><br></pre></td></tr></table></figure><h4 id="HTTP-methods"><a href="#HTTP-methods" class="headerlink" title="HTTP methods"></a>HTTP methods</h4>Defines how data communicated through Internet.</li></ol><ul><li>GET:retrieve data and has no side effect</li><li>POST:add resources to server</li><li>HEAD, DELETE, PATCH<br>fetch(url,{method:”GET”}), returns a promise containing the result of that call. .json() returns another promise contained in th returned result. .then(response=&gt;response.json()).then(jsons=&gt;console.log(jsons)).<h4 id="ES7-amp-amp-ES8"><a href="#ES7-amp-amp-ES8" class="headerlink" title="ES7 &amp;&amp; ES8"></a>ES7 &amp;&amp; ES8</h4>ES7</li></ul><ol><li>exponential operator,2**5-32.</li><li>support for arrays. arr.includes(2) == true<br>npm install babel-preset-es2016 babel-preset-es2017<br>ES8</li><li>access object manipulate with .values()+.entries()<br>let a ={‘a’:1,’b’:2};let keys = Object.keys(a)/values(a);<br>let entries = Object.entries(a);<br>for(let cur of entries) {cur[0]}</li><li>Async. don’t want logic to continue until get relavant data in functions. Use await to temprtial stop the execution of statements and logic until finishes returning a promises.</li></ol><p>CSS3<br>column-count:3<br>column-rule:线型<br>column-gap:40px;之间的间距<br>z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。越大离用户越近。</p><p><left></left></p><p><right></right></p><p><main><br>.left {<br>    float:left;<br>    width:200px;<br>}<br>.right {<br>    float:right;<br>    width:200px;<br>}<br>.main {<br>    margin-left:200px;<br>    margin-right:200px;<br>}</main></p><p>{<br>    position:absolute;<br>    width:400px<br>    height:400px;<br>    top:50%;<br>    left:50%;<br>    margin-top:-200px;<br>    margin-left:-200px;<br>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JS-basic&quot;&gt;&lt;a href=&quot;#JS-basic&quot; class=&quot;headerlink&quot; title=&quot;JS basic&quot;&gt;&lt;/a&gt;JS basic&lt;/h2&gt;&lt;p&gt;JS is OOScripting language.&lt;br&gt;JS on the client side access the DOM.&lt;br&gt;JS on the server side can communicate with databases.&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="front-end" scheme="http://yoursite.com/tags/front-end/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
</feed>
